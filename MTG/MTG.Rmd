---
title: "A workflow for single cell RNA-seq data analysis: MTG dataset"
author: "Paul Little, Wei Sun"
date: "`r Sys.Date()`"
output: 
  html_document:
    theme: journal
    highlight: tango
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: true
      smooth_scroll: false
    number_sections: true
bibliography: MTG.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

This markdown is for analyzing the [Allen Brain Atlas MTG dataset](http://celltypes.brain-map.org/rnaseq). While some details of their analysis is provided [here](http://help.brain-map.org/download/attachments/8323525/CellTypes_Transcriptomics_Overview.pdf), we ran a workflow similar to the DroNc dataset.

The packages required for the analysis are as follows:
- DropletUtils: provides functions for data from droplet technologies such as 10X Genomics
- biomaRt: provides easy access to databases, such as Ensembl, COSMIC, Uniprot, HGNC, etc.
- scater: collection of tools for doing quality control analyses of scRNA-seq
- scran: methods provide normalization of cell-specific biases, correcting batch effects, identify marker genes
- SC3: package for single cell consensus clustering.

# Obtaining/Loading Counts

The dataset is available [here](http://celltypes.brain-map.org/api/v2/well_known_file_download/694416044). This markdown is designed to download all necessary packages and input data objects for analysis.

Before running this R markdown, change the following `repo_dir` and `data_dir` variables to your own respective local working directory. Also, determine if the analysis will be conducted with exon counts only(`exon_only = TRUE`) or with both exon and intron counts summed together (`exon_only = FALSE`).

```{r}
# Specifying working directories
repo_dir = "/pine/scr/p/l/pllittle/CS_eQTL/s3_Real/scRNAseq_pipelines"
data_dir = file.path(repo_dir,"MTG")
setwd(data_dir)

# Analysis Plans
exon_only = TRUE

# Source/Libraries
source(file.path(repo_dir,"SOURCE.R"))
# biocLite("BiocUpgrade")
bio_packs = c("SingleCellExperiment","DropletUtils","biomaRt","scater","scran","SC3")
if( !all(bio_packs %in% installed.packages()[,"Package"]) ){
        source("https://bioconductor.org/biocLite.R")
        biocLite(bio_packs,suppressUpdates = TRUE)
}
cran_packs = c("stringi","irlba")
if( !all(cran_packs %in% installed.packages()[,"Package"]) ){
        install.packages(cran_packs)
}
suppressPackageStartupMessages(library(SingleCellExperiment))
suppressPackageStartupMessages(library(DropletUtils))
suppressPackageStartupMessages(library(biomaRt))
suppressPackageStartupMessages(library(scater))
suppressPackageStartupMessages(library(scran))
suppressPackageStartupMessages(library(limma))

# Import counts
if( exon_only ){
	counts_fn = file.path(data_dir,"exons.rds")
} else {
	counts_fn = file.path(data_dir,"exons_introns.rds")
}
if( !file.exists(counts_fn) ){
	file_link = "http://celltypes.brain-map.org/api/v2/well_known_file_download/694416044"
	file_name = strsplit(file_link,"/")[[1]]
	file_name = file_name[length(file_name)]
	file_name = file.path(data_dir,file_name)
	if( !file.exists(file_name) ){
		cmd = sprintf("cd %s; wget %s",data_dir,file_link)
		system(cmd)
	}
	cmd = sprintf("cd %s; unzip -o %s",data_dir,file_name); system(cmd)
	
	exons_fn = file.path(data_dir,"human_MTG_2018-06-14_exon-matrix.csv")
	num_lines = as.numeric(system(sprintf("wc -l %s | cut -d ' ' -f1",exons_fn),intern = TRUE))
	cat(paste0("Reading in ",exons_fn,"\n"))
	exon_counts = read.delim(exons_fn,sep = ',',header = TRUE,row.names = 1,check.names = FALSE,nrows = num_lines - 1)
	exon_counts = as.matrix(exon_counts)

	introns_fn = file.path(data_dir,"human_MTG_2018-06-14_intron-matrix.csv")
	num_lines = as.numeric(system(sprintf("wc -l %s | cut -d ' ' -f1",introns_fn),intern = TRUE))
	cat(paste0("Reading in ",introns_fn,"\n"))
	intron_counts = read.delim(introns_fn,sep = ',',header = TRUE,row.names = 1,check.names = FALSE,nrows = num_lines - 1)
	intron_counts = as.matrix(intron_counts)

	exon_intron_counts = exon_counts + intron_counts
	
	saveRDS(exon_counts,file.path(data_dir,"exons.rds"))
	saveRDS(intron_counts,file.path(data_dir,"introns.rds"))
	saveRDS(exon_intron_counts,file.path(data_dir,"exons_introns.rds"))
}

counts = readRDS(counts_fn)
cell_data = smart_RT("human_MTG_2018-06-14_samples-columns.csv",sep=',',header=TRUE)

# Double check samples are correctly sorted
all(colnames(counts) == cell_data$sample_name)
sce = SingleCellExperiment(assays = list(counts = as.matrix(counts)),colData = cell_data)
rm(counts,cell_data)

# Import gene info
gene_dat = smart_RT("human_MTG_2018-06-14_genes-rows.csv",sep=',',header=TRUE)
all(rownames(sce) == as.character(gene_dat$entrez_id))
rowData(sce) = gene_dat; rm(gene_dat)
sce

# Checking spikes
rowData(sce)[grep("^ERCC",rowData(sce)$gene),]
sce

```

# Pre-processing: Quality Control, Gene Detection, Normalization

### Incorporate Mito and Ribo to calculate QC metrics

Next step we apply QC based on a set of features per cell. We will look at ribosomal genes. The imported file can be found [here](https://www.genenames.org/cgi-bin/genefamilies/set/1054/download/branch).

```{r warning = FALSE, message = FALSE}
file_link = "https://www.genenames.org/cgi-bin/genefamilies/set/1054/download/branch"
file_name = strsplit(file_link,"/")[[1]]
file_name = file_name[length(file_name)]
ribo_fn = file.path(data_dir,file_name)
if( !file.exists(ribo_fn) ){
	cmd = sprintf("cd %s; wget %s",data_dir,file_link)
	print(cmd)
	system(cmd)
}

ribo = smart_RT(ribo_fn,sep='\t',header=TRUE)
dim(ribo)
ribo[1:2,]

table(rowData(sce)$chromosome)
is_mito = which(rowData(sce)$chromosome == "MT")
is_ribo = which(rowData(sce)$gene %in% ribo$Approved.Symbol)
length(is_mito)
length(is_ribo)
```

Now we will calculate QC metrics for each sample. The code and filtering below are motivated by the vignette presented [here](https://bioconductor.org/packages/release/workflows/vignettes/simpleSingleCell/inst/doc/work-1-reads.html#32_identifying_outliers_for_each_metric).
```{r fig.width = 12,fig.height = 12}
sort(names(colData(sce)))
sort(names(rowData(sce)))
sce = calculateQCMetrics(sce,feature_controls=list(Mt=is_mito, Ri=is_ribo))
sort(names(colData(sce)))
sort(names(rowData(sce)))

par(mfrow=c(2,2), mar=c(5, 4, 1, 1), bty="n")
smart_hist(log10(sce$total_counts),xlab="log10(Library sizes)", main="", 
	breaks=20,ylab="Number of cells")
smart_hist(log10(sce$total_features),xlab="log10(# of expressed genes)", 
	main="", breaks=20,ylab="Number of cells")
smart_hist(sce$pct_counts_Ri, xlab="Ribosome prop. (%)",
	ylab="Number of cells", breaks=40, main="")
smart_hist(sce$pct_counts_Mt, xlab="Mitochondrial prop. (%)", 
	ylab="Number of cells", breaks=80, main="")
smoothScatter(log10(sce$total_counts), log10(sce$total_features), 
	xlab="log10(Library sizes)", ylab="log10(# of expressed genes)", 
	nrpoints=500, cex=0.5)
smoothScatter(log10(sce$total_counts), sce$pct_counts_Ri, 
	xlab="log10(Library sizes)", ylab="Ribosome prop. (%)",
	nrpoints=500, cex=0.5)
smoothScatter(log10(sce$total_counts), sce$pct_counts_Mt, 
	xlab="log10(Library sizes)", ylab="Mitochondrial prop. (%)",
	nrpoints=500, cex=0.5)
smoothScatter(sce$pct_counts_Ri, sce$pct_counts_Mt, 
	xlab="Ribosome prop. (%)", ylab="Mitochondrial prop. (%)",
	nrpoints=500, cex=0.5)
smart_hist(sce$pct_counts_Ri,breaks=40,xlab="Ribosome prop. (%)")
smart_hist(sce$pct_counts_Mt,breaks=40,xlab="Mitochondrial prop. (%)")
plot(x=sce$pct_counts_Ri,y=sce$pct_counts_Mt,pch=16,col=rgb(0,0,0,0.4),
	xlab="Ribosome prop. (%)", ylab="Mitochondrial prop. (%)")
# ribo_cut = 1.5; mito_cut = 1; abline(v=ribo_cut,lty=2); abline(h=mito_cut,lty=2)
par(mfrow=c(1,1))

# Removing outliers defined as being lower or higher than 3 MADs from the median of each metric
libsize_drop = isOutlier(sce$total_counts,nmads=3,type="lower",log=TRUE)
feature_drop = isOutlier(sce$total_features_by_counts,nmads=3,type="lower",log=TRUE)
mito_drop = isOutlier(sce$pct_counts_Mt,nmads=3,type="higher")
ribo_drop = isOutlier(sce$pct_counts_Ri,nmads=3,type="higher")

keep = !(libsize_drop | feature_drop | mito_drop | ribo_drop)
data.frame(ByLibSize=sum(libsize_drop),ByFeature=sum(feature_drop),
    ByMito=sum(mito_drop),ByRibo=sum(ribo_drop),Remaining=sum(keep))
```

We then subset the `sce` object to keep high quality samples(cells). In addition, we save the original object. 
```{r}
sce$PassQC = keep
saveRDS(sce,"preQC.rds")
sce = sce[,keep]
dim(sce)
```

## Summarize gene-level information
```{r warning = FALSE, message = FALSE,fig.width=12,fig.height=12}

rowData(sce)[1:2,]
summary(rowData(sce)$mean_counts)
summary(rowData(sce)$mean_counts[rowData(sce)$mean_counts>0])
summary(rowData(sce)$n_cells_counts)

par(mfrow=c(2,2), mar=c(5,4,1,1))
smart_hist(log10(rowData(sce)$mean_counts+1e-6),main="",
	breaks=40, xlab="log10(ave # of UMI + 1e-6)")
smart_hist(log10(rowData(sce)$n_cells_counts+1),main="",
	breaks=40, xlab="log10(# of expressed cells + 1)")
smoothScatter(log10(rowData(sce)$mean_counts+1e-6),
	log10(rowData(sce)$n_cells_counts + 1),
	xlab="log10(ave # of UMI + 1e-6)",
	ylab="log10(# of expressed cells + 1)")
par(mfrow=c(1,1),mar=c(5,4,4,2)+0.1)

tb1 = table(rowData(sce)$n_cells_counts)
tb1[1:11]

# Filter genes
par(mfrow=c(2,1),mar=c(5,4,1,1))
smart_hist(rowData(sce)$n_cells_counts,breaks=50,xlab="# of expressed cells")
smart_hist(log10(1+rowData(sce)$n_cells_counts),breaks=50,xlab="log10(1 + # of expressed cells)")
par(mfrow=c(1,1))

n_cell_count_filter = rowData(sce)$n_cells_counts > 5
table(n_cell_count_filter)

min_detect_min_sample = apply(counts(sce),1,function(xx) length(which(xx > 0)) > 10)
table(min_detect_min_sample)

sce = sce[which(n_cell_count_filter == TRUE),]
dim(sce)

# Next we check those highly expressed genes 
par(mfrow=c(2,1),mar=c(5,8,1,1))
od1 = order(rowData(sce)$mean_counts, decreasing = TRUE)
barplot(rowData(sce)$mean_counts[od1[20:1]], las=1, 
	names.arg=rowData(sce)$gene[od1[20:1]], 
	horiz=TRUE, cex.names=1, cex.axis=0.7, 
	xlab="ave # of UMI")
barplot(log10(rowData(sce)$mean_counts[od1[20:1]]), las=1, 
	names.arg=rowData(sce)$gene[od1[20:1]], 
	horiz=TRUE, cex.names=1, cex.axis=0.7, 
	xlab="log10(ave # of UMI)")
par(mar=c(5,4,1,1))

saveRDS(sce,"post_gene_filter.rds")
```

## Normalization
A simple solution for normalization and stablizing expression varaince across genes is to tranform the count data by log(count/size.factor + 1). One may calcualte size.factor per cell as the total number of UMIs, and this assumes the total expression are the same across all the cells. However, the total expression of each cell may vary with respect to cell type and/or cell size, and the ```computeSumFactors``` function in R package scran provides a more  sophisicated way to calcualte size.factor to allow such variaation across cells [@lun2016pooling]. ```computeSumFactors``` can use initial clustering of cells to normalize expression within and beetween clusters.  Within a cluster, it estimates the size factor for many groups of cells so that there are more groups than cells, and then it can calcualte the size factor per cell using a lienar deconvolution system. 

As shown in the following plot, the final size factor estimation is indeed highly correlated with the naive definition by total count. 

Finally, the command ```normalize(sce)``` adds the normalized expression into the variable ```sce```.
```{r warning = FALSE, message = FALSE,fig.width=14,fig.height=8}

date()
clusters = quickCluster(sce, min.mean=0.1, method="igraph")
date()
sce = computeSumFactors(sce, cluster=clusters, min.mean=0.1)
date()
summary(sizeFactors(sce))

# Remove cells with negative or very small size factors
dim(sce)
sce = sce[,which(sizeFactors(sce) > 0)]
dim(sce)

par(mfrow=c(1,2), mar=c(5,4,2,1), bty="n")
smoothScatter(sce$total_counts, sizeFactors(sce), log="xy", 
	xlab="total counts", ylab="size factors")
plot(sce$total_counts, sizeFactors(sce), log="xy", 
	xlab="total counts", ylab="size factors", 
	cex=0.3, pch=20, col=rgb(0.1,0.2,0.7,0.3))
par(mfrow=c(1,1))

sce = normalize(sce)

saveRDS(sce,"post_norm.rds")
```

## Dimension reduction

For dimension reduction, such as calculating PCA or performing TSNE, we should start by identifying a subset of genes with high level of biological signal relative to background (technical) noise. The ```decomposeVar``` function from R/cran is designed for this task. 
```{r warning = FALSE, message = FALSE, fig.height=8,fig.width=8}
date()
new_trend = makeTechTrend(x=sce)
date()
fit = trendVar(sce, use.spikes=FALSE, loess.args=list(span=0.05))

par(mfrow=c(1,1), mar=c(5,4,2,1), bty="n")
plot(fit$mean, fit$var, pch=20, col=rgb(0.1,0.2,0.7,0.6), 
	xlab="log(mean)", ylab="var")
curve(fit$trend(x), col="orange", lwd=2, add=TRUE)
curve(new_trend(x), col="red", lwd=2, add=TRUE)
legend("topright", legend=c("Poisson noise", "observed trend"), 
	lty=1, lwd=2, col=c("red", "orange"), bty="n")


###########
fit$trend = new_trend
dec = decomposeVar(fit=fit)
top.dec = dec[order(dec$bio, decreasing=TRUE),]
plotExpression(sce, features=rownames(top.dec)[1:10])
```

When performing PCA, we can use all the genes or just those genes with high signal-to-noise ratio. TSNE analysis is usually based on the top PCs rather than the original gene expression data. We first perform PCA using all the genes and the function ```denoisePCA``` can automatically select the PCs based on modeling of technical noise. 

```{r warning = FALSE, message = FALSE, fig.height=8,fig.width=11}
date()
sce = denoisePCA(sce, technical=new_trend, approx=TRUE)
date()
dim(reducedDim(sce, "PCA"))

plot(log10(attr(reducedDim(sce), "percentVar")), xlab="PC",
     ylab="log10(Prop of variance explained)", pch=20, cex=0.6, 
     col=rgb(0.8, 0.2, 0.2, 0.5))
abline(v=ncol(reducedDim(sce, "PCA")), lty=2, col="red")


df_pcs = data.frame(reducedDim(sce, "PCA"))
df_pcs$log10_total_features = colData(sce)$log10_total_features

gp1 = ggplot(df_pcs, aes(PC1,PC2,col=log10_total_features)) + 
  geom_point(size=0.2,alpha=0.6) + theme_classic() + 
  scale_colour_gradient(low="lightblue",high="red") +
  guides(color = guide_legend(override.aes = list(size=3)))
gp1

date()
sce = runTSNE(sce, use_dimred="PCA", perplexity=30, rand_seed=100)
date()

df_tsne = data.frame(reducedDim(sce, "TSNE"))
df_tsne$log10_total_features = colData(sce)$log10_total_features

gp1 = ggplot(df_tsne, aes(X1,X2,col=log10_total_features)) + 
  geom_point(size=0.2,alpha=0.6) + theme_classic() + 
  scale_colour_gradient(low="lightblue",high="red") +
  guides(color = guide_legend(override.aes = list(size=3)))
gp1

# Save temp image
post_dimRed_fn = file.path(data_dir,"post_dimRed.rds")
saveRDS(list(sce=sce,dec=dec),post_dimRed_fn)
```

Next we only select around top 1000 genes for the PCA and use the top 50 PCs for TSNE projection. 

```{r warning = FALSE, message = FALSE, fig.asp = 0.8}


library(svd)
library(Rtsne)

summary(dec$bio)
dec1 = dec
dec1$bio[which(dec$bio < 1e-8)] = 1e-8
dec1$FDR[which(dec$FDR < 1e-100)] = 1e-100

par(mfrow=c(1,2))
hist(log10(dec1$bio), breaks=100, main="")
hist(log10(dec1$FDR), breaks=100, main="")

summary(dec$FDR[dec$bio > 0.001])
table(dec$FDR < 1e-10, dec$bio > 0.01)

w2kp = which(dec$FDR < 1e-10 & dec$bio > 0.01)
sce_sub = sce[w2kp,]
sce_sub

edat = t(as.matrix(logcounts(sce_sub)))
edat = scale(edat)
dim(edat)
edat[1:2,1:3]

date()
ppk = propack.svd(edat,neig=50)
date()
pca = t(ppk$d*t(ppk$u))

df_pcs = data.frame(pca)
df_pcs$log10_total_features = colData(sce_sub)$log10_total_features
df_pcs[1:2,]

gp1 = ggplot(df_pcs, aes(X1,X2,col=log10_total_features)) + 
  geom_point(size=0.2,alpha=0.6) + theme_classic() + 
  scale_colour_gradient(low="lightblue",high="red") +
  guides(color = guide_legend(override.aes = list(size=3)))
gp1

set.seed(100)
date()
tsne = Rtsne(pca, pca = FALSE)
date()

df_tsne = data.frame(tsne$Y)
df_tsne$log10_total_features = colData(sce_sub)$log10_total_features
dim(df_tsne)
df_tsne[1:2,]

gp1 = ggplot(df_tsne, aes(X1,X2,col=log10_total_features)) + 
  geom_point(size=0.2,alpha=0.6) + theme_classic() + 
  scale_colour_gradient(low="lightblue",high="red") +
  guides(color = guide_legend(override.aes = list(size=3)))
gp1

reducedDims(sce_sub) = SimpleList(PCA=pca, TSNE=tsne$Y)
sce_sub

post_redDim_fn = file.path(data_dir,"post_redDim.rds")
saveRDS(list(sce=sce,sce_sub=sce_sub,df_tsne=df_tsne),post_redDim_fn)
```

## Clustering

### Kmeans
There are many methods for clustering of single cell RNA-seq data. The performance of each method may also depend on pre-processing steps, such as performing imputation or not. We wil compare these methods in a seperate document. Here we just illustrate the clustering reuslts using a simple kmeans method on the top 50 PCs. 

```{r warning = FALSE, message = FALSE, fig.asp = 1}

k10_50_pcs = kmeans(reducedDim(sce_sub, "PCA"), centers=10, 
                    iter.max=150, algorithm="MacQueen")
names(k10_50_pcs)
dim(k10_50_pcs$centers)

df_tsne$cluster_kmean = as.factor(k10_50_pcs$cluster)
cols = c("#FB9A99","#FF7F00","yellow","orchid","grey",
         "red","dodgerblue2","tan4","green4","#99c9fb")

gp1 = ggplot(df_tsne, aes(X1,X2,col=cluster_kmean)) + 
  geom_point(size=0.2,alpha=0.6) + theme_classic() + 
  scale_color_manual(values=cols) + 
  guides(color = guide_legend(override.aes = list(size=3)))
gp1

# Save temp image
post_cluster_fn = file.path(data_dir,"post_cluster.rds")
saveRDS(list(sce=sce,sce_sub=sce_sub,
	k10_50_pcs=k10_50_pcs,df_tsne=df_tsne),
	post_cluster_fn)

```

### SC3
Code used here is based on [this link](https://bioconductor.org/packages/devel/bioc/vignettes/SC3/inst/doc/SC3.html#run-sc3).

```{r fig.height=14, fig.width=14}
library(SC3)
rowData(sce)$feature_symbol = rowData(sce)$gene
date()
all_ks = c(10,15)
sce = sc3(sce, 
	ks = all_ks,biology = TRUE,
	n_cores = 1,rand_seed = 100,
	svm_num_cells = 2000)
warnings()
date()

# Run SVM and predict labels of all other cells
date()
sce = sc3_run_svm(sce, ks = all_ks)
date()

# Save temp image
post_sc3_fn = file.path(data_dir,"post_sc3.rds")
saveRDS(list(sce=sce,all_ks=all_ks),post_sc3_fn)

# Plotting
for(one_ks in all_ks){
  # one_ks = 2
  print(one_ks)
  plotPCA(sce,
      colour_by = paste0("sc3_",one_ks,"_clusters"), 
      size_by = paste0("sc3_",one_ks,"_log2_outlier_score"))
  
  sc3_plot_consensus(sce,k = one_ks,
      show_pdata = c("log10_total_features",
        paste0("sc3_",one_ks,"_clusters"), 
        paste0("sc3_",one_ks,"_log2_outlier_score")))
  
  sc3_plot_silhouette(sce, k = one_ks)
  
  sc3_plot_expression(sce, k = one_ks,
      show_pdata = c("log10_total_features",
        paste0("sc3_",one_ks,"_clusters"), 
        paste0("sc3_",one_ks,"_log2_outlier_score")))
  
  sc3_plot_cluster_stability(sce, k = one_ks)
  
  sc3_plot_de_genes(sce, k = one_ks, 
    show_pdata = c("log10_total_features",
        paste0("sc3_",one_ks,"_clusters"), 
        paste0("sc3_",one_ks,"_log2_outlier_score")))
  
  sc3_plot_markers(sce, k = one_ks, 
    show_pdata = c("log10_total_features",
        paste0("sc3_",one_ks,"_clusters"), 
        paste0("sc3_",one_ks,"_log2_outlier_score")))
  
}


```


# Session information
```{r}
sessionInfo()
```

# Reference

