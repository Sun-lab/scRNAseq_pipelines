<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Introduction</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>





<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Introduction</h1>

<p>This markdown is for analyzing the <a href="http://celltypes.brain-map.org/rnaseq">Allen Brain Atlas MTG dataset</a>. While some details of their analysis is provided <a href="http://help.brain-map.org/download/attachments/8323525/CellTypes_Transcriptomics_Overview.pdf">here</a>, we ran a workflow similar to the DroNc dataset.</p>

<p>The packages required for the analysis are as follows:</p>

<ul>
<li>DropletUtils: provides functions for data from droplet technologies such as 10X Genomics</li>
<li>biomaRt: provides easy access to databases, such as Ensembl, COSMIC, Uniprot, HGNC, etc.</li>
<li>scater: collection of tools for doing quality control analyses of scRNA-seq</li>
<li>scran: methods provide normalization of cell-specific biases, correcting batch effects, identify marker genes</li>
<li>SC3: package for single cell consensus clustering.</li>
</ul>

<h1>Obtaining/Loading Counts</h1>

<p>The dataset is available <a href="http://celltypes.brain-map.org/api/v2/well_known_file_download/694416044">here</a>. This markdown is designed to download all necessary packages and input data objects for analysis.</p>

<p>Before running this R markdown, change the following <code>repo_dir</code> and <code>data_dir</code> variables to your own respective local working directory. Also, determine if the analysis will be conducted with exon counts only(<code>exon_only = TRUE</code>) or with both exon and intron counts summed together (<code>exon_only = FALSE</code>).</p>

<pre><code class="r"># Specifying working directories
repo_dir = &quot;/pine/scr/p/l/pllittle/CS_eQTL/s3_Real/scRNAseq_pipelines&quot;
data_dir = file.path(repo_dir,&quot;MTG&quot;)
setwd(data_dir)

# Analysis Plans
exon_only = TRUE

# Source/Libraries
source(file.path(repo_dir,&quot;SOURCE.R&quot;))
# biocLite(&quot;BiocUpgrade&quot;)
bio_packs = c(&quot;SingleCellExperiment&quot;,&quot;DropletUtils&quot;,&quot;biomaRt&quot;,&quot;scater&quot;,&quot;scran&quot;,&quot;SC3&quot;)
if( !all(bio_packs %in% installed.packages()[,&quot;Package&quot;]) ){
        source(&quot;https://bioconductor.org/biocLite.R&quot;)
        biocLite(bio_packs,suppressUpdates = TRUE)
}
cran_packs = c(&quot;stringi&quot;,&quot;irlba&quot;)
if( !all(cran_packs %in% installed.packages()[,&quot;Package&quot;]) ){
        install.packages(cran_packs)
}
suppressPackageStartupMessages(library(SingleCellExperiment))
suppressPackageStartupMessages(library(DropletUtils))
suppressPackageStartupMessages(library(biomaRt))
suppressPackageStartupMessages(library(scater))
suppressPackageStartupMessages(library(scran))
suppressPackageStartupMessages(library(limma))

# Import counts
if( exon_only ){
    counts_fn = file.path(data_dir,&quot;exons.rds&quot;)
} else {
    counts_fn = file.path(data_dir,&quot;exons_introns.rds&quot;)
}
if( !file.exists(counts_fn) ){
    file_link = &quot;http://celltypes.brain-map.org/api/v2/well_known_file_download/694416044&quot;
    file_name = strsplit(file_link,&quot;/&quot;)[[1]]
    file_name = file_name[length(file_name)]
    file_name = file.path(data_dir,file_name)
    if( !file.exists(file_name) ){
        cmd = sprintf(&quot;cd %s; wget %s&quot;,data_dir,file_link)
        system(cmd)
    }
    cmd = sprintf(&quot;cd %s; unzip -o %s&quot;,data_dir,file_name); system(cmd)

    exons_fn = file.path(data_dir,&quot;human_MTG_2018-06-14_exon-matrix.csv&quot;)
    num_lines = as.numeric(system(sprintf(&quot;wc -l %s | cut -d &#39; &#39; -f1&quot;,exons_fn),intern = TRUE))
    cat(paste0(&quot;Reading in &quot;,exons_fn,&quot;\n&quot;))
    exon_counts = read.delim(exons_fn,sep = &#39;,&#39;,header = TRUE,row.names = 1,check.names = FALSE,nrows = num_lines - 1)
    exon_counts = as.matrix(exon_counts)

    introns_fn = file.path(data_dir,&quot;human_MTG_2018-06-14_intron-matrix.csv&quot;)
    num_lines = as.numeric(system(sprintf(&quot;wc -l %s | cut -d &#39; &#39; -f1&quot;,introns_fn),intern = TRUE))
    cat(paste0(&quot;Reading in &quot;,introns_fn,&quot;\n&quot;))
    intron_counts = read.delim(introns_fn,sep = &#39;,&#39;,header = TRUE,row.names = 1,check.names = FALSE,nrows = num_lines - 1)
    intron_counts = as.matrix(intron_counts)

    exon_intron_counts = exon_counts + intron_counts

    saveRDS(exon_counts,file.path(data_dir,&quot;exons.rds&quot;))
    saveRDS(intron_counts,file.path(data_dir,&quot;introns.rds&quot;))
    saveRDS(exon_intron_counts,file.path(data_dir,&quot;exons_introns.rds&quot;))
}

counts = readRDS(counts_fn)
cell_data = smart_RT(&quot;human_MTG_2018-06-14_samples-columns.csv&quot;,sep=&#39;,&#39;,header=TRUE)

# Double check samples are correctly sorted
all(colnames(counts) == cell_data$sample_name)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">sce = SingleCellExperiment(assays = list(counts = as.matrix(counts)),colData = cell_data)
colData(sce)$cluster0 = sapply(colData(sce)$cluster,function(xx) strsplit(xx,&quot; &quot;)[[1]][1],USE.NAMES=FALSE)
colData(sce)$cluster0[which(colData(sce)$cluster0 == &quot;no&quot;)] = &quot;no class&quot;
rm(counts,cell_data)

# Import gene info
gene_dat = smart_RT(&quot;human_MTG_2018-06-14_genes-rows.csv&quot;,sep=&#39;,&#39;,header=TRUE)
all(rownames(sce) == as.character(gene_dat$entrez_id))
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">rowData(sce) = gene_dat; rm(gene_dat)
rownames(sce) = rowData(sce)$gene
sce
</code></pre>

<pre><code>## class: SingleCellExperiment 
## dim: 50281 15928 
## metadata(0):
## assays(1): counts
## rownames(50281): 3.8-1.2 3.8-1.3 ... bA255A11.4 bA395L14.12
## rowData names(5): gene chromosome entrez_id gene_name
##   mouse_homologenes
## colnames(15928): F1S4_160106_001_B01 F1S4_160106_001_C01 ...
##   F2S4_170405_060_F01 F2S4_170405_060_H01
## colData names(35): sample_name sample_id ... cluster cluster0
## reducedDimNames(0):
## spikeNames(0):
</code></pre>

<pre><code class="r"># Checking spikes
rowData(sce)[grep(&quot;^ERCC&quot;,rowData(sce)$gene),]
</code></pre>

<pre><code>## DataFrame with 10 rows and 5 columns
##           gene  chromosome entrez_id
##    &lt;character&gt; &lt;character&gt; &lt;integer&gt;
## 1        ERCC1          19      2067
## 2        ERCC2          19      2068
## 3        ERCC3           2      2071
## 4        ERCC4          16      2072
## 5        ERCC5          13      2073
## 6        ERCC6          10      2074
## 7  ERCC6-PGBD3          10 101243544
## 8       ERCC6L           X     54821
## 9      ERCC6L2           9    375748
## 10       ERCC8           5      1161
##                                               gene_name mouse_homologenes
##                                             &lt;character&gt;       &lt;character&gt;
## 1         excision repair cross-complementation group 1             Ercc1
## 2         excision repair cross-complementation group 2             Ercc2
## 3         excision repair cross-complementation group 3             Ercc3
## 4         excision repair cross-complementation group 4             Ercc4
## 5         excision repair cross-complementation group 5             Ercc5
## 6         excision repair cross-complementation group 6             Ercc6
## 7                               ERCC6-PGBD3 readthrough                  
## 8    excision repair cross-complementation group 6-like            Ercc6l
## 9  excision repair cross-complementation group 6-like 2           Ercc6l2
## 10        excision repair cross-complementation group 8             Ercc8
</code></pre>

<pre><code class="r">sce
</code></pre>

<pre><code>## class: SingleCellExperiment 
## dim: 50281 15928 
## metadata(0):
## assays(1): counts
## rownames(50281): 3.8-1.2 3.8-1.3 ... bA255A11.4 bA395L14.12
## rowData names(5): gene chromosome entrez_id gene_name
##   mouse_homologenes
## colnames(15928): F1S4_160106_001_B01 F1S4_160106_001_C01 ...
##   F2S4_170405_060_F01 F2S4_170405_060_H01
## colData names(35): sample_name sample_id ... cluster cluster0
## reducedDimNames(0):
## spikeNames(0):
</code></pre>

<h1>Pre-processing: Quality Control, Gene Detection, Normalization</h1>

<h3>Incorporate Mito and Ribo to calculate QC metrics</h3>

<p>Next step we apply QC based on a set of features per cell. We will look at ribosomal genes. The imported file can be found <a href="https://www.genenames.org/cgi-bin/genefamilies/set/1054/download/branch">here</a>.</p>

<pre><code class="r">file_link = &quot;https://www.genenames.org/cgi-bin/genefamilies/set/1054/download/branch&quot;
file_name = strsplit(file_link,&quot;/&quot;)[[1]]
file_name = file_name[length(file_name)]
ribo_fn = file.path(data_dir,file_name)
if( !file.exists(ribo_fn) ){
    cmd = sprintf(&quot;cd %s; wget %s&quot;,data_dir,file_link)
    print(cmd)
    system(cmd)
}

ribo = smart_RT(ribo_fn,sep=&#39;\t&#39;,header=TRUE)
dim(ribo)
</code></pre>

<pre><code>## [1] 163  12
</code></pre>

<pre><code class="r">ribo[1:2,]
</code></pre>

<pre><code>##   HGNC.ID Approved.Symbol          Approved.Name   Status Previous.Symbols
## 1   10298           RPL10  ribosomal protein L10 Approved                 
## 2   10299          RPL10A ribosomal protein L10a Approved            NEDD6
##                                  Synonyms Chromosome Accession.Numbers
## 1 NOV, QM, DXS648E, DXS648, FLJ23544, L10       Xq28          AB007170
## 2                            Csa-19, L10A    6p21.31            U12404
##   RefSeq.IDs Gene.Family.Tag Gene.family.description Gene.family.ID
## 1  NM_006013             RPL    L ribosomal proteins            729
## 2  NM_007104             RPL    L ribosomal proteins            729
</code></pre>

<pre><code class="r">table(rowData(sce)$chromosome)
</code></pre>

<pre><code>## 
##    1   10   11   12   13   14   15   16   17   18   19    2   20   21   22 
## 4688 2038 2793 2387 1322 1931 1712 1818 2292  937 2413 3592 1243  725 1128 
##    3    4    5    6    7    8    9   MT    X    Y 
## 2776 2250 2375 2685 2579 1999 2129   37 1969  463
</code></pre>

<pre><code class="r">is_mito = which(rowData(sce)$chromosome == &quot;MT&quot;)
is_ribo = which(rowData(sce)$gene %in% ribo$Approved.Symbol)
length(is_mito)
</code></pre>

<pre><code>## [1] 37
</code></pre>

<pre><code class="r">length(is_ribo)
</code></pre>

<pre><code>## [1] 163
</code></pre>

<p>Now we will calculate QC metrics for each sample. The code and filtering below are motivated by the vignette presented <a href="https://bioconductor.org/packages/release/workflows/vignettes/simpleSingleCell/inst/doc/work-1-reads.html#32_identifying_outliers_for_each_metric">here</a>.</p>

<pre><code class="r">sort(names(colData(sce)))
</code></pre>

<pre><code>##  [1] &quot;age_days&quot;                      &quot;brain_hemisphere&quot;             
##  [3] &quot;brain_region&quot;                  &quot;brain_subregion&quot;              
##  [5] &quot;class&quot;                         &quot;cluster&quot;                      
##  [7] &quot;cluster0&quot;                      &quot;complexity_cg&quot;                
##  [9] &quot;donor&quot;                         &quot;facs_container&quot;               
## [11] &quot;facs_date&quot;                     &quot;facs_sort_criteria&quot;           
## [13] &quot;genes_detected_cpm_criterion&quot;  &quot;genes_detected_fpkm_criterion&quot;
## [15] &quot;library_prep_avg_size_bp&quot;      &quot;library_prep_set&quot;             
## [17] &quot;organism&quot;                      &quot;percent_aligned_reads_total&quot;  
## [19] &quot;percent_ecoli_reads&quot;           &quot;percent_exon_reads&quot;           
## [21] &quot;percent_intergenic_reads&quot;      &quot;percent_intron_reads&quot;         
## [23] &quot;percent_mt_exon_reads&quot;         &quot;percent_reads_unique&quot;         
## [25] &quot;percent_rrna_reads&quot;            &quot;percent_synth_reads&quot;          
## [27] &quot;rna_amplification_set&quot;         &quot;sample_id&quot;                    
## [29] &quot;sample_name&quot;                   &quot;sample_type&quot;                  
## [31] &quot;seq_batch&quot;                     &quot;seq_name&quot;                     
## [33] &quot;seq_tube&quot;                      &quot;sex&quot;                          
## [35] &quot;total_reads&quot;
</code></pre>

<pre><code class="r">sort(names(rowData(sce)))
</code></pre>

<pre><code>## [1] &quot;chromosome&quot;        &quot;entrez_id&quot;         &quot;gene&quot;             
## [4] &quot;gene_name&quot;         &quot;mouse_homologenes&quot;
</code></pre>

<pre><code class="r">sce = calculateQCMetrics(sce,feature_controls=list(Mt=is_mito, Ri=is_ribo))
</code></pre>

<pre><code>## Note that the names of some metrics have changed, see &#39;Renamed metrics&#39; in ?calculateQCMetrics.
## Old names are currently maintained for back-compatibility, but may be removed in future releases.
</code></pre>

<pre><code class="r">sort(names(colData(sce)))
</code></pre>

<pre><code>##  [1] &quot;age_days&quot;                                      
##  [2] &quot;brain_hemisphere&quot;                              
##  [3] &quot;brain_region&quot;                                  
##  [4] &quot;brain_subregion&quot;                               
##  [5] &quot;class&quot;                                         
##  [6] &quot;cluster&quot;                                       
##  [7] &quot;cluster0&quot;                                      
##  [8] &quot;complexity_cg&quot;                                 
##  [9] &quot;donor&quot;                                         
## [10] &quot;facs_container&quot;                                
## [11] &quot;facs_date&quot;                                     
## [12] &quot;facs_sort_criteria&quot;                            
## [13] &quot;genes_detected_cpm_criterion&quot;                  
## [14] &quot;genes_detected_fpkm_criterion&quot;                 
## [15] &quot;is_cell_control&quot;                               
## [16] &quot;library_prep_avg_size_bp&quot;                      
## [17] &quot;library_prep_set&quot;                              
## [18] &quot;log10_total_counts&quot;                            
## [19] &quot;log10_total_counts_endogenous&quot;                 
## [20] &quot;log10_total_counts_feature_control&quot;            
## [21] &quot;log10_total_counts_Mt&quot;                         
## [22] &quot;log10_total_counts_Ri&quot;                         
## [23] &quot;log10_total_features&quot;                          
## [24] &quot;log10_total_features_by_counts&quot;                
## [25] &quot;log10_total_features_by_counts_endogenous&quot;     
## [26] &quot;log10_total_features_by_counts_feature_control&quot;
## [27] &quot;log10_total_features_by_counts_Mt&quot;             
## [28] &quot;log10_total_features_by_counts_Ri&quot;             
## [29] &quot;log10_total_features_endogenous&quot;               
## [30] &quot;log10_total_features_feature_control&quot;          
## [31] &quot;log10_total_features_Mt&quot;                       
## [32] &quot;log10_total_features_Ri&quot;                       
## [33] &quot;organism&quot;                                      
## [34] &quot;pct_counts_endogenous&quot;                         
## [35] &quot;pct_counts_feature_control&quot;                    
## [36] &quot;pct_counts_in_top_100_features&quot;                
## [37] &quot;pct_counts_in_top_100_features_endogenous&quot;     
## [38] &quot;pct_counts_in_top_100_features_feature_control&quot;
## [39] &quot;pct_counts_in_top_100_features_Ri&quot;             
## [40] &quot;pct_counts_in_top_200_features&quot;                
## [41] &quot;pct_counts_in_top_200_features_endogenous&quot;     
## [42] &quot;pct_counts_in_top_200_features_feature_control&quot;
## [43] &quot;pct_counts_in_top_50_features&quot;                 
## [44] &quot;pct_counts_in_top_50_features_endogenous&quot;      
## [45] &quot;pct_counts_in_top_50_features_feature_control&quot; 
## [46] &quot;pct_counts_in_top_50_features_Ri&quot;              
## [47] &quot;pct_counts_in_top_500_features&quot;                
## [48] &quot;pct_counts_in_top_500_features_endogenous&quot;     
## [49] &quot;pct_counts_Mt&quot;                                 
## [50] &quot;pct_counts_Ri&quot;                                 
## [51] &quot;pct_counts_top_100_features&quot;                   
## [52] &quot;pct_counts_top_100_features_endogenous&quot;        
## [53] &quot;pct_counts_top_100_features_feature_control&quot;   
## [54] &quot;pct_counts_top_100_features_Ri&quot;                
## [55] &quot;pct_counts_top_200_features&quot;                   
## [56] &quot;pct_counts_top_200_features_endogenous&quot;        
## [57] &quot;pct_counts_top_200_features_feature_control&quot;   
## [58] &quot;pct_counts_top_50_features&quot;                    
## [59] &quot;pct_counts_top_50_features_endogenous&quot;         
## [60] &quot;pct_counts_top_50_features_feature_control&quot;    
## [61] &quot;pct_counts_top_50_features_Ri&quot;                 
## [62] &quot;pct_counts_top_500_features&quot;                   
## [63] &quot;pct_counts_top_500_features_endogenous&quot;        
## [64] &quot;percent_aligned_reads_total&quot;                   
## [65] &quot;percent_ecoli_reads&quot;                           
## [66] &quot;percent_exon_reads&quot;                            
## [67] &quot;percent_intergenic_reads&quot;                      
## [68] &quot;percent_intron_reads&quot;                          
## [69] &quot;percent_mt_exon_reads&quot;                         
## [70] &quot;percent_reads_unique&quot;                          
## [71] &quot;percent_rrna_reads&quot;                            
## [72] &quot;percent_synth_reads&quot;                           
## [73] &quot;rna_amplification_set&quot;                         
## [74] &quot;sample_id&quot;                                     
## [75] &quot;sample_name&quot;                                   
## [76] &quot;sample_type&quot;                                   
## [77] &quot;seq_batch&quot;                                     
## [78] &quot;seq_name&quot;                                      
## [79] &quot;seq_tube&quot;                                      
## [80] &quot;sex&quot;                                           
## [81] &quot;total_counts&quot;                                  
## [82] &quot;total_counts_endogenous&quot;                       
## [83] &quot;total_counts_feature_control&quot;                  
## [84] &quot;total_counts_Mt&quot;                               
## [85] &quot;total_counts_Ri&quot;                               
## [86] &quot;total_features&quot;                                
## [87] &quot;total_features_by_counts&quot;                      
## [88] &quot;total_features_by_counts_endogenous&quot;           
## [89] &quot;total_features_by_counts_feature_control&quot;      
## [90] &quot;total_features_by_counts_Mt&quot;                   
## [91] &quot;total_features_by_counts_Ri&quot;                   
## [92] &quot;total_features_endogenous&quot;                     
## [93] &quot;total_features_feature_control&quot;                
## [94] &quot;total_features_Mt&quot;                             
## [95] &quot;total_features_Ri&quot;                             
## [96] &quot;total_reads&quot;
</code></pre>

<pre><code class="r">sort(names(rowData(sce)))
</code></pre>

<pre><code>##  [1] &quot;chromosome&quot;            &quot;entrez_id&quot;            
##  [3] &quot;gene&quot;                  &quot;gene_name&quot;            
##  [5] &quot;is_feature_control&quot;    &quot;is_feature_control_Mt&quot;
##  [7] &quot;is_feature_control_Ri&quot; &quot;log10_mean_counts&quot;    
##  [9] &quot;log10_total_counts&quot;    &quot;mean_counts&quot;          
## [11] &quot;mouse_homologenes&quot;     &quot;n_cells_by_counts&quot;    
## [13] &quot;n_cells_counts&quot;        &quot;pct_dropout_by_counts&quot;
## [15] &quot;pct_dropout_counts&quot;    &quot;total_counts&quot;
</code></pre>

<pre><code class="r">par(mfrow=c(2,2), mar=c(5, 4, 1, 1), bty=&quot;n&quot;)
smart_hist(log10(sce$total_counts),xlab=&quot;log10(Library sizes)&quot;, main=&quot;&quot;, 
    breaks=20,ylab=&quot;Number of cells&quot;)
smart_hist(log10(sce$total_features),xlab=&quot;log10(# of expressed genes)&quot;, 
    main=&quot;&quot;, breaks=20,ylab=&quot;Number of cells&quot;)
smart_hist(sce$pct_counts_Ri, xlab=&quot;Ribosome prop. (%)&quot;,
    ylab=&quot;Number of cells&quot;, breaks=40, main=&quot;&quot;)
smart_hist(sce$pct_counts_Mt, xlab=&quot;Mitochondrial prop. (%)&quot;, 
    ylab=&quot;Number of cells&quot;, breaks=80, main=&quot;&quot;)
</code></pre>

<p><img src="figure/unnamed-chunk-3-1.png" alt="plot of chunk unnamed-chunk-3"></p>

<pre><code class="r">smoothScatter(log10(sce$total_counts), log10(sce$total_features), 
    xlab=&quot;log10(Library sizes)&quot;, ylab=&quot;log10(# of expressed genes)&quot;, 
    nrpoints=500, cex=0.5)
smoothScatter(log10(sce$total_counts), sce$pct_counts_Ri, 
    xlab=&quot;log10(Library sizes)&quot;, ylab=&quot;Ribosome prop. (%)&quot;,
    nrpoints=500, cex=0.5)
smoothScatter(log10(sce$total_counts), sce$pct_counts_Mt, 
    xlab=&quot;log10(Library sizes)&quot;, ylab=&quot;Mitochondrial prop. (%)&quot;,
    nrpoints=500, cex=0.5)
</code></pre>

<pre><code>## Warning in KernSmooth::bkde2D(x, bandwidth = bandwidth, gridsize = nbin, :
## Binning grid too coarse for current (small) bandwidth: consider increasing
## &#39;gridsize&#39;
</code></pre>

<pre><code class="r">smoothScatter(sce$pct_counts_Ri, sce$pct_counts_Mt, 
    xlab=&quot;Ribosome prop. (%)&quot;, ylab=&quot;Mitochondrial prop. (%)&quot;,
    nrpoints=500, cex=0.5)
</code></pre>

<pre><code>## Warning in KernSmooth::bkde2D(x, bandwidth = bandwidth, gridsize = nbin, :
## Binning grid too coarse for current (small) bandwidth: consider increasing
## &#39;gridsize&#39;
</code></pre>

<p><img src="figure/unnamed-chunk-3-2.png" alt="plot of chunk unnamed-chunk-3"></p>

<pre><code class="r">smart_hist(sce$pct_counts_Ri,breaks=40,xlab=&quot;Ribosome prop. (%)&quot;)
smart_hist(sce$pct_counts_Mt,breaks=40,xlab=&quot;Mitochondrial prop. (%)&quot;)
plot(x=sce$pct_counts_Ri,y=sce$pct_counts_Mt,pch=16,col=rgb(0,0,0,0.4),
    xlab=&quot;Ribosome prop. (%)&quot;, ylab=&quot;Mitochondrial prop. (%)&quot;)
# ribo_cut = 1.5; mito_cut = 1; abline(v=ribo_cut,lty=2); abline(h=mito_cut,lty=2)
par(mfrow=c(1,1))
</code></pre>

<p><img src="figure/unnamed-chunk-3-3.png" alt="plot of chunk unnamed-chunk-3"></p>

<pre><code class="r"># Removing outliers defined as being lower or higher than 3 MADs from the median of each metric
libsize_drop = isOutlier(sce$total_counts,nmads=3,type=&quot;lower&quot;,log=TRUE)
feature_drop = isOutlier(sce$total_features_by_counts,nmads=3,type=&quot;lower&quot;,log=TRUE)
mito_drop = isOutlier(sce$pct_counts_Mt,nmads=3,type=&quot;higher&quot;)
ribo_drop = isOutlier(sce$pct_counts_Ri,nmads=3,type=&quot;higher&quot;)

keep = !(libsize_drop | feature_drop | mito_drop | ribo_drop)
data.frame(ByLibSize=sum(libsize_drop),ByFeature=sum(feature_drop),
    ByMito=sum(mito_drop),ByRibo=sum(ribo_drop),Remaining=sum(keep))
</code></pre>

<pre><code>##   ByLibSize ByFeature ByMito ByRibo Remaining
## 1       222       514   1668    434     13330
</code></pre>

<p>We then subset the <code>sce</code> object to keep high quality samples(cells). In addition, we save the original object. </p>

<pre><code class="r">sce$PassQC = keep
saveRDS(sce,&quot;preQC.rds&quot;)
sce = sce[,keep]
dim(sce)
</code></pre>

<pre><code>## [1] 50281 13330
</code></pre>

<pre><code class="r"># To load image
# sce = readRDS(&quot;preQC.rds&quot;); sce = sce[,which(colData(sce)$PassQC == TRUE)]
</code></pre>

<h2>Summarize gene-level information</h2>

<pre><code class="r">rowData(sce)[1:2,]
</code></pre>

<pre><code>## DataFrame with 2 rows and 16 columns
##          gene  chromosome entrez_id
##   &lt;character&gt; &lt;character&gt; &lt;integer&gt;
## 1     3.8-1.2           6    353007
## 2     3.8-1.3           6    353008
##                                              gene_name mouse_homologenes
##                                            &lt;character&gt;       &lt;character&gt;
## 1 HLA complex group 26 (non-protein coding) pseudogene                  
## 2 HLA complex group 26 (non-protein coding) pseudogene                  
##   is_feature_control is_feature_control_Mt is_feature_control_Ri
##            &lt;logical&gt;             &lt;logical&gt;             &lt;logical&gt;
## 1              FALSE                 FALSE                 FALSE
## 2              FALSE                 FALSE                 FALSE
##           mean_counts   log10_mean_counts n_cells_by_counts
##             &lt;numeric&gt;           &lt;numeric&gt;         &lt;integer&gt;
## 1 0.00878955298844802 0.00380057604028069                 7
## 2  0.0573204419889503   0.024206628837133                21
##   pct_dropout_by_counts total_counts log10_total_counts n_cells_counts
##               &lt;numeric&gt;    &lt;integer&gt;          &lt;numeric&gt;      &lt;integer&gt;
## 1      99.9560522350578          140   2.14921911265538              7
## 2      99.8681567051733          913   2.96094619573383             21
##   pct_dropout_counts
##            &lt;numeric&gt;
## 1   99.9560522350578
## 2   99.8681567051733
</code></pre>

<pre><code class="r">summary(rowData(sce)$mean_counts)
</code></pre>

<pre><code>##      Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
##      0.00      0.02      0.31     15.13      5.56 101644.02
</code></pre>

<pre><code class="r">summary(rowData(sce)$mean_counts[rowData(sce)$mean_counts&gt;0])
</code></pre>

<pre><code>##      Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
##      0.00      0.03      0.38     15.75      6.28 101644.02
</code></pre>

<pre><code class="r">summary(rowData(sce)$n_cells_counts)
</code></pre>

<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##       0      30     244    1744    1893   15928
</code></pre>

<pre><code class="r">par(mfrow=c(2,2), mar=c(5,4,1,1))
smart_hist(log10(rowData(sce)$mean_counts+1e-6),main=&quot;&quot;,
    breaks=40, xlab=&quot;log10(ave # of UMI + 1e-6)&quot;)
smart_hist(log10(rowData(sce)$n_cells_counts+1),main=&quot;&quot;,
    breaks=40, xlab=&quot;log10(# of expressed cells + 1)&quot;)
smoothScatter(log10(rowData(sce)$mean_counts+1e-6),
    log10(rowData(sce)$n_cells_counts + 1),
    xlab=&quot;log10(ave # of UMI + 1e-6)&quot;,
    ylab=&quot;log10(# of expressed cells + 1)&quot;)
par(mfrow=c(1,1),mar=c(5,4,4,2)+0.1)
</code></pre>

<p><img src="figure/unnamed-chunk-5-1.png" alt="plot of chunk unnamed-chunk-5"></p>

<pre><code class="r">tb1 = table(rowData(sce)$n_cells_counts)
tb1[1:11]
</code></pre>

<pre><code>## 
##    0    1    2    3    4    5    6    7    8    9   10 
## 2003  567  555  559  662  574  539  562  494  441  445
</code></pre>

<pre><code class="r"># Filter genes
par(mfrow=c(2,1),mar=c(5,4,1,1))
smart_hist(rowData(sce)$n_cells_counts,breaks=50,xlab=&quot;# of expressed cells&quot;)
smart_hist(log10(1+rowData(sce)$n_cells_counts),breaks=50,xlab=&quot;log10(1 + # of expressed cells)&quot;)
</code></pre>

<p><img src="figure/unnamed-chunk-5-2.png" alt="plot of chunk unnamed-chunk-5"></p>

<pre><code class="r">par(mfrow=c(1,1))

n_cell_count_filter = rowData(sce)$n_cells_counts &gt; 5
    table(n_cell_count_filter)
</code></pre>

<pre><code>## n_cell_count_filter
## FALSE  TRUE 
##  4920 45361
</code></pre>

<pre><code class="r">min_detect_min_sample = apply(counts(sce),1,function(xx) length(which(xx &gt; 0)) &gt; 10)
    table(min_detect_min_sample)
</code></pre>

<pre><code>## min_detect_min_sample
## FALSE  TRUE 
##  8330 41951
</code></pre>

<pre><code class="r">min_mean_counts0 = rowData(sce)$mean_counts &gt; 0
    table(min_mean_counts0)
</code></pre>

<pre><code>## min_mean_counts0
## FALSE  TRUE 
##  2003 48278
</code></pre>

<pre><code class="r">min_mean_counts1 = rowData(sce)$mean_counts &gt; 1
    table(min_mean_counts1)
</code></pre>

<pre><code>## min_mean_counts1
## FALSE  TRUE 
## 30728 19553
</code></pre>

<pre><code class="r">table(n_cell_count_filter,min_detect_min_sample,min_mean_counts0,min_mean_counts1)
</code></pre>

<pre><code>## , , min_mean_counts0 = FALSE, min_mean_counts1 = FALSE
## 
##                    min_detect_min_sample
## n_cell_count_filter FALSE  TRUE
##               FALSE  2003     0
##               TRUE      0     0
## 
## , , min_mean_counts0 = TRUE, min_mean_counts1 = FALSE
## 
##                    min_detect_min_sample
## n_cell_count_filter FALSE  TRUE
##               FALSE  2917     0
##               TRUE   3410 22398
## 
## , , min_mean_counts0 = FALSE, min_mean_counts1 = TRUE
## 
##                    min_detect_min_sample
## n_cell_count_filter FALSE  TRUE
##               FALSE     0     0
##               TRUE      0     0
## 
## , , min_mean_counts0 = TRUE, min_mean_counts1 = TRUE
## 
##                    min_detect_min_sample
## n_cell_count_filter FALSE  TRUE
##               FALSE     0     0
##               TRUE      0 19553
</code></pre>

<pre><code class="r">sce = sce[which(rowData(sce)$mean_counts &gt; 1),]
dim(sce)
</code></pre>

<pre><code>## [1] 19553 13330
</code></pre>

<pre><code class="r"># Next we check those highly expressed genes 
par(mfrow=c(1,2),mar=c(5,8,1,1))
od1 = order(rowData(sce)$mean_counts, decreasing = TRUE)
barplot(rowData(sce)$mean_counts[od1[20:1]], las=1, 
    names.arg=rowData(sce)$gene[od1[20:1]], 
    horiz=TRUE, cex.names=1, cex.axis=0.7, 
    xlab=&quot;ave # of UMI&quot;)
barplot(log10(rowData(sce)$mean_counts[od1[20:1]]), las=1, 
    names.arg=rowData(sce)$gene[od1[20:1]], 
    horiz=TRUE, cex.names=1, cex.axis=0.7, 
    xlab=&quot;log10(ave # of UMI)&quot;)
</code></pre>

<p><img src="figure/unnamed-chunk-5-3.png" alt="plot of chunk unnamed-chunk-5"></p>

<pre><code class="r">par(mar=c(5,4,1,1))

saveRDS(sce,&quot;post_gene_filter.rds&quot;)
# To load image
# sce = readRDS(&quot;post_gene_filter.rds&quot;)
</code></pre>

<h2>Normalization</h2>

<p>A simple solution for normalization and stablizing expression varaince across genes is to tranform the count data by log(count/size.factor + 1). One may calcualte size.factor per cell as the total number of UMIs, and this assumes the total expression are the same across all the cells. However, the total expression of each cell may vary with respect to cell type and/or cell size, and the <code>computeSumFactors</code> function in R package scran provides a more  sophisicated way to calcualte size.factor to allow such variaation across cells [@lun2016pooling]. <code>computeSumFactors</code> can use initial clustering of cells to normalize expression within and beetween clusters.  Within a cluster, it estimates the size factor for many groups of cells so that there are more groups than cells, and then it can calcualte the size factor per cell using a lienar deconvolution system. </p>

<p>As shown in the following plot, the final size factor estimation is indeed highly correlated with the naive definition by total count. </p>

<p>Finally, the command <code>normalize(sce)</code> adds the normalized expression into the variable <code>sce</code>.</p>

<pre><code class="r">min_mean = 1
date()
</code></pre>

<pre><code>## [1] &quot;Mon Nov  5 15:31:04 2018&quot;
</code></pre>

<pre><code class="r">clusters = quickCluster(sce, min.mean=min_mean, method=&quot;igraph&quot;)
table(clusters)
</code></pre>

<pre><code>## clusters
##    1    2    3    4    5    6    7 
##  946 1284 1539  334 3513 4036 1678
</code></pre>

<pre><code class="r">date()
</code></pre>

<pre><code>## [1] &quot;Mon Nov  5 15:34:54 2018&quot;
</code></pre>

<pre><code class="r">sce = computeSumFactors(sce, cluster=clusters, min.mean=min_mean)
date()
</code></pre>

<pre><code>## [1] &quot;Mon Nov  5 15:40:12 2018&quot;
</code></pre>

<pre><code class="r">summary(sizeFactors(sce))
</code></pre>

<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.3005  0.8219  0.9922  1.0000  1.1535  6.4986
</code></pre>

<pre><code class="r"># Remove cells with negative or very small size factors
dim(sce)
</code></pre>

<pre><code>## [1] 19553 13330
</code></pre>

<pre><code class="r">sce = sce[,which(sizeFactors(sce) &gt; 0)]
dim(sce)
</code></pre>

<pre><code>## [1] 19553 13330
</code></pre>

<pre><code class="r">par(mfrow=c(1,2), mar=c(5,4,2,1), bty=&quot;n&quot;)
smoothScatter(sce$total_counts, sizeFactors(sce), log=&quot;xy&quot;, 
    xlab=&quot;total counts&quot;, ylab=&quot;size factors&quot;)
plot(sce$total_counts, sizeFactors(sce), log=&quot;xy&quot;, 
    xlab=&quot;total counts&quot;, ylab=&quot;size factors&quot;, 
    cex=0.3, pch=20, col=rgb(0.1,0.2,0.7,0.3))
</code></pre>

<p><img src="figure/unnamed-chunk-6-1.png" alt="plot of chunk unnamed-chunk-6"></p>

<pre><code class="r">par(mfrow=c(1,1))

sce = normalize(sce)
saveRDS(sce,&quot;post_norm.rds&quot;)
</code></pre>

<p>The link at <a href="https://bioconductor.org/packages/devel/workflows/vignettes/simpleSingleCell/inst/doc/work-1-reads.html#61_using_the_deconvolution_method_to_deal_with_zero_counts">here</a> mentions the choice of setting <code>min.mean</code>.</p>

<p>Since the MTG dataset does not contain spikeIn transcripts, we implemented the code below similar to <a href="http://bioconductor.org/packages/devel/workflows/vignettes/simpleSingleCell/inst/doc/xtra-3-var.html#32_when_spike-ins_are_unavailable">here</a>.</p>

<h2>Dimension reduction</h2>

<p>For dimension reduction, such as calculating PCA or performing TSNE, we should start by identifying a subset of genes with high level of biological signal relative to background (technical) noise. The <code>decomposeVar</code> function from R/cran is designed for this task. </p>

<pre><code class="r">date()
</code></pre>

<pre><code>## [1] &quot;Mon Nov  5 15:43:17 2018&quot;
</code></pre>

<pre><code class="r">new_trend = makeTechTrend(x=sce)
date()
</code></pre>

<pre><code>## [1] &quot;Mon Nov  5 15:48:56 2018&quot;
</code></pre>

<pre><code class="r">fit = trendVar(sce, use.spikes=FALSE, loess.args=list(span=0.05))

par(mfrow=c(1,1), mar=c(5,4,2,1), bty=&quot;n&quot;)
plot(fit$mean, fit$vars, pch=20, col=rgb(0.1,0.2,0.7,0.6), 
    xlab=&quot;log(mean)&quot;, ylab=&quot;var&quot;)
curve(new_trend(x), col=&quot;red&quot;, lwd=2, add=TRUE)
curve(fit$trend(x), col=&quot;orange&quot;, lwd=2, add=TRUE)
legend(&quot;topright&quot;, legend=c(&quot;Poisson noise&quot;, &quot;observed trend&quot;), 
    lty=1, lwd=2, col=c(&quot;red&quot;, &quot;orange&quot;), bty=&quot;n&quot;)
</code></pre>

<p><img src="figure/unnamed-chunk-7-1.png" alt="plot of chunk unnamed-chunk-7"></p>

<p>The above function <code>makeTechTrend()</code> assumes a Poisson model and from the above plot, it is clearly not a suitable fit. So we will keep <code>fit</code> equal to the loess fit from <code>trendVar()</code> rather than setting it equal to the output from <code>makeTechTrend()</code>.</p>

<pre><code class="r"># fit$trend = new_trend
dec = decomposeVar(fit=fit)
top_dec = dec[order(dec$bio,decreasing=TRUE),]
top_dec[1:10,]
</code></pre>

<pre><code>## DataFrame with 10 rows and 6 columns
##                        mean            total              bio
##                   &lt;numeric&gt;        &lt;numeric&gt;        &lt;numeric&gt;
## ENC1       6.46897568522746  16.628678834938 8.43783037939368
## GAD1        2.4024213091023 16.5187400191716 7.45143686428273
## SPARCL1    7.46752154947916 13.1935765758566 6.85261720241952
## ARPP21     7.25891975098436 13.4421386002274 6.76418774946179
## SLC6A1     2.66533608460488  16.071961808116  6.4824519643573
## KCNIP4-IT1 5.98579750935527 15.4453475001772 6.38301994618043
## CHN1       8.31754772682424 11.4003777853178 6.33075234070888
## NECAB1     5.66460335462768 15.8505611904774 6.30339027185692
## CCK         5.8124411593409 15.6064656008162 6.28035350903205
## SYNPR      2.78133711115622 15.6698208866094 5.84524345158222
##                        tech   p.value       FDR
##                   &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;
## ENC1       8.19084845554428         0         0
## GAD1       9.06730315488888         0         0
## SPARCL1    6.34095937343706         0         0
## ARPP21      6.6779508507656         0         0
## SLC6A1     9.58950984375866         0         0
## KCNIP4-IT1 9.06232755399677         0         0
## CHN1       5.06962544460892         0         0
## NECAB1     9.54717091862051         0         0
## CCK        9.32611209178411         0         0
## SYNPR      9.82457743502718         0         0
</code></pre>

<pre><code class="r">par(mfrow=c(2,2))
smart_hist(dec$bio,breaks=30,xlab=&quot;Biological Variance&quot;)
smart_hist(dec$FDR,breaks=30,xlab=&quot;FDR&quot;)
smart_hist(log10(dec$FDR + 1e-6),breaks=30,xlab=&quot;log10(FDR + 1e-6)&quot;)
par(mfrow=c(1,1))
</code></pre>

<p><img src="figure/unnamed-chunk-8-1.png" alt="plot of chunk unnamed-chunk-8"></p>

<pre><code class="r">plotExpression(sce, features=rownames(top_dec)[1:10])
</code></pre>

<p><img src="figure/unnamed-chunk-8-2.png" alt="plot of chunk unnamed-chunk-8"></p>

<p>When performing PCA, we can use all the genes or just those genes with high signal-to-noise ratio. TSNE analysis is usually based on the top PCs rather than the original gene expression data. We first perform PCA using all the genes and the function <code>denoisePCA</code> can automatically select the PCs based on modeling of technical noise. </p>

<pre><code class="r">date()
</code></pre>

<pre><code>## [1] &quot;Mon Nov  5 15:49:41 2018&quot;
</code></pre>

<pre><code class="r">sce = denoisePCA(sce,technical=fit$trend,approx=TRUE)
date()
</code></pre>

<pre><code>## [1] &quot;Mon Nov  5 16:00:16 2018&quot;
</code></pre>

<pre><code class="r">dim(reducedDim(sce,&quot;PCA&quot;))
</code></pre>

<pre><code>## [1] 13330     7
</code></pre>

<pre><code class="r">par(mfrow=c(1,1))
plot(log10(attr(reducedDim(sce), &quot;percentVar&quot;)), xlab=&quot;PC&quot;,
     ylab=&quot;log10(Prop of variance explained)&quot;, pch=20, cex=0.6, 
     col=rgb(0.8, 0.2, 0.2, 0.5))
abline(v=ncol(reducedDim(sce,&quot;PCA&quot;)), lty=2, col=&quot;red&quot;)
</code></pre>

<p><img src="figure/unnamed-chunk-9-1.png" alt="plot of chunk unnamed-chunk-9"></p>

<pre><code class="r">df_redDim = smart_df(sample_name = colnames(sce),reducedDim(sce, &quot;PCA&quot;))
rownames(df_redDim) = NULL
df_redDim$log10_total_features = colData(sce)$log10_total_features
df_redDim$sex = colData(sce)$sex
df_redDim$brain_hemisphere = colData(sce)$brain_hemisphere
df_redDim$brain_subregion = colData(sce)$brain_subregion
df_redDim$facs_sort_criteria = colData(sce)$facs_sort_criteria
df_redDim$class = colData(sce)$class
df_redDim$cluster = colData(sce)$cluster
df_redDim$cluster0 = colData(sce)$cluster0

all_vars = c(&quot;log10_total_features&quot;,&quot;sex&quot;,&quot;brain_hemisphere&quot;,
    &quot;brain_subregion&quot;,&quot;facs_sort_criteria&quot;,&quot;class&quot;,&quot;cluster&quot;,
    &quot;cluster0&quot;)
for(one_var in all_vars){
    print(ggplot_custom(DATA = df_redDim,
        X = &quot;PC1&quot;,Y = &quot;PC2&quot;,COL = one_var))
}
</code></pre>

<p><img src="figure/unnamed-chunk-9-2.png" alt="plot of chunk unnamed-chunk-9"><img src="figure/unnamed-chunk-9-3.png" alt="plot of chunk unnamed-chunk-9"><img src="figure/unnamed-chunk-9-4.png" alt="plot of chunk unnamed-chunk-9"><img src="figure/unnamed-chunk-9-5.png" alt="plot of chunk unnamed-chunk-9"><img src="figure/unnamed-chunk-9-6.png" alt="plot of chunk unnamed-chunk-9"><img src="figure/unnamed-chunk-9-7.png" alt="plot of chunk unnamed-chunk-9"><img src="figure/unnamed-chunk-9-8.png" alt="plot of chunk unnamed-chunk-9"><img src="figure/unnamed-chunk-9-9.png" alt="plot of chunk unnamed-chunk-9"></p>

<pre><code class="r">date()
</code></pre>

<pre><code>## [1] &quot;Mon Nov  5 16:00:25 2018&quot;
</code></pre>

<pre><code class="r">sce = runTSNE(sce,use_dimred=&quot;PCA&quot;,perplexity=30,rand_seed=100)
date()
</code></pre>

<pre><code>## [1] &quot;Mon Nov  5 16:06:35 2018&quot;
</code></pre>

<pre><code class="r">df_redDim = smart_df(df_redDim,reducedDim(sce,&quot;TSNE&quot;))
rownames(df_redDim) = NULL
names(df_redDim)[c(ncol(df_redDim)-1,ncol(df_redDim))] = paste0(&quot;TSNE&quot;,1:2)

for(one_var in all_vars){
    print(ggplot_custom(DATA = df_redDim,
        X = &quot;TSNE1&quot;,Y = &quot;TSNE2&quot;,COL = one_var))
}
</code></pre>

<p><img src="figure/unnamed-chunk-9-10.png" alt="plot of chunk unnamed-chunk-9"><img src="figure/unnamed-chunk-9-11.png" alt="plot of chunk unnamed-chunk-9"><img src="figure/unnamed-chunk-9-12.png" alt="plot of chunk unnamed-chunk-9"><img src="figure/unnamed-chunk-9-13.png" alt="plot of chunk unnamed-chunk-9"><img src="figure/unnamed-chunk-9-14.png" alt="plot of chunk unnamed-chunk-9"><img src="figure/unnamed-chunk-9-15.png" alt="plot of chunk unnamed-chunk-9"><img src="figure/unnamed-chunk-9-16.png" alt="plot of chunk unnamed-chunk-9"><img src="figure/unnamed-chunk-9-17.png" alt="plot of chunk unnamed-chunk-9"></p>

<pre><code class="r">saveRDS(list(sce=sce,dec=dec),&quot;post_redDim_all_genes.rds&quot;)
# Note that this contains the results from PCA and TSNE with all genes
# rds = readRDS(&quot;post_redDim_all_genes.rds&quot;); sce = rds$sce; dec = rds$dec; rm(rds)
</code></pre>

<p>Next we only select approximately the top 1000 highly variable genes for the PCA, based on tuning thresholds on <code>dec$bio</code> and <code>dec$FDR</code> from the earlier variance decomposition, and use the top 50 PCs for TSNE projection. </p>

<pre><code class="r">library(svd)
library(Rtsne)

summary(dec$bio)
</code></pre>

<pre><code>##     Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
## -9.90110 -0.26727  0.01702 -0.04618  0.32695  8.43783
</code></pre>

<pre><code class="r">summary(dec$FDR)
</code></pre>

<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.0000  0.0000  0.4044  0.4988  1.0000  1.0000
</code></pre>

<pre><code class="r">dec1 = dec
dec1$bio[which(dec1$bio &lt; 1e-8)] = 1e-8
dec1$FDR[which(dec1$FDR &lt; 1e-100)] = 1e-100

par(mfrow=c(2,2))
smart_hist(log10(dec1$bio),breaks=100,main=&quot;&quot;,xlab=&quot;log10(bio)&quot;)
smart_hist(log10(dec1$FDR),breaks=100,main=&quot;&quot;,xlab=&quot;log10(FDR)&quot;)
smoothScatter(log10(dec1$bio),log10(dec1$FDR),xlab=&quot;log10(bio)&quot;,ylab=&quot;log10(FDR)&quot;)

summary(dec$FDR[dec$bio &gt; 0.001])
</code></pre>

<pre><code>##      Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
## 0.0000000 0.0000000 0.0000000 0.0523775 0.0006214 0.9281177
</code></pre>

<pre><code class="r">FDR_thres = 1e-50 # 1e-10
bio_thres = 1e-1 # 1e-2
FDR_keep = dec$FDR &lt; FDR_thres
bio_keep = dec$bio &gt; bio_thres
table(FDR_keep,bio_keep)
</code></pre>

<pre><code>##         bio_keep
## FDR_keep FALSE  TRUE
##    FALSE 11789  6698
##    TRUE     15  1051
</code></pre>

<pre><code class="r">w2kp = which(dec1$FDR &lt; FDR_thres &amp; dec1$bio &gt; bio_thres)

# Subsetting highly variable genes for subsequent PCA and TSNE
sce_hvg = sce[w2kp,]
sce_hvg
</code></pre>

<pre><code>## class: SingleCellExperiment 
## dim: 1051 13330 
## metadata(1): log.exprs.offset
## assays(2): counts logcounts
## rownames(1051): AASDHPPT AASS ... ZWINT ZXDB
## rowData names(16): gene chromosome ... n_cells_counts
##   pct_dropout_counts
## colnames(13330): F1S4_160106_001_C01 F1S4_160106_001_G01 ...
##   F2S4_170405_060_F01 F2S4_170405_060_H01
## colData names(97): sample_name sample_id ...
##   pct_counts_top_100_features_Ri PassQC
## reducedDimNames(2): PCA TSNE
## spikeNames(0):
</code></pre>

<pre><code class="r">edat = t(as.matrix(logcounts(sce_hvg)))
edat = scale(edat)
dim(edat)
</code></pre>

<pre><code>## [1] 13330  1051
</code></pre>

<pre><code class="r">edat[1:2,1:3]
</code></pre>

<pre><code>##                       AASDHPPT       AASS      ABCA8
## F1S4_160106_001_C01 -0.9405765 -0.3007532 -0.1450556
## F1S4_160106_001_G01  0.6180050 -0.3007532 -0.1450556
</code></pre>

<pre><code class="r">date()
</code></pre>

<pre><code>## [1] &quot;Mon Nov  5 16:09:58 2018&quot;
</code></pre>

<pre><code class="r">ppk = propack.svd(edat,neig=50)
date()
</code></pre>

<pre><code>## [1] &quot;Mon Nov  5 16:10:10 2018&quot;
</code></pre>

<pre><code class="r">pca = t(ppk$d*t(ppk$u))
dim(pca)
</code></pre>

<pre><code>## [1] 13330    50
</code></pre>

<pre><code class="r">df_hvg = smart_df(pca)
rownames(df_hvg) = NULL
names(df_hvg) = paste0(&quot;PC&quot;,seq(ncol(df_hvg)))
df_hvg = smart_df(sample_name = colnames(sce_hvg),df_hvg)
df_hvg$log10_total_features = colData(sce_hvg)$log10_total_features
df_hvg$sex = colData(sce_hvg)$sex
df_hvg$brain_hemisphere = colData(sce_hvg)$brain_hemisphere
df_hvg$brain_subregion = colData(sce_hvg)$brain_subregion
df_hvg$facs_sort_criteria = colData(sce_hvg)$facs_sort_criteria
df_hvg$class = colData(sce_hvg)$class
df_hvg$cluster = colData(sce_hvg)$cluster
df_hvg$cluster0 = colData(sce_hvg)$cluster0

all_vars = c(&quot;log10_total_features&quot;,&quot;sex&quot;,&quot;brain_hemisphere&quot;,
    &quot;brain_subregion&quot;,&quot;facs_sort_criteria&quot;,&quot;class&quot;,&quot;cluster&quot;,
    &quot;cluster0&quot;)
for(one_var in all_vars){
    print(ggplot_custom(DATA = df_hvg,
        X = &quot;PC1&quot;,Y = &quot;PC2&quot;,COL = one_var))
}

set.seed(100)
date()
</code></pre>

<pre><code>## [1] &quot;Mon Nov  5 16:10:19 2018&quot;
</code></pre>

<pre><code class="r">tsne = Rtsne(pca, pca = FALSE)
date()
</code></pre>

<pre><code>## [1] &quot;Mon Nov  5 16:16:39 2018&quot;
</code></pre>

<pre><code class="r">df_tsne = smart_df(tsne$Y)
names(df_tsne) = paste0(&quot;TSNE&quot;,seq(ncol(tsne$Y)))
dim(df_tsne)
</code></pre>

<pre><code>## [1] 13330     2
</code></pre>

<pre><code class="r"># df_tsne[1:2,]
df_hvg = smart_df(df_hvg,df_tsne)
df_hvg[1:2,]
</code></pre>

<pre><code>##           sample_name       PC1        PC2      PC3       PC4        PC5
## 1 F1S4_160106_001_C01 -8.097259 -0.2014815 7.295970 3.9360922  2.8916705
## 2 F1S4_160106_001_G01 -4.172508 -0.6629105 7.281139 0.6082552 -0.1053634
##         PC6       PC7       PC8      PC9      PC10     PC11      PC12
## 1  2.440887  1.151182 -0.628315 1.102461  1.114636 0.387628  1.589772
## 2 -1.984740 -4.487737 -6.788227 4.565291 -1.455726 3.845174 10.006559
##        PC13      PC14       PC15      PC16      PC17      PC18       PC19
## 1 -1.934514  0.376387 -1.3027737  4.207579 -2.102668 -2.065592  2.5296738
## 2  5.690378 -3.815942  0.3587115 -1.908718 -1.599769 -1.222584 -0.9246038
##        PC20      PC21       PC22       PC23      PC24      PC25      PC26
## 1 -2.860216 -1.205244  2.5837956 -2.4284231 0.6026073 0.2505768  2.267628
## 2  1.261222  2.856862 -0.1447852 -0.7795055 1.3047175 0.2881669 -1.475536
##        PC27     PC28       PC29       PC30       PC31       PC32
## 1 1.3672071 2.102565  3.0881205 -0.4170079 -2.5408516 -2.0235607
## 2 0.3243705 2.481185 -0.2767881 -1.6481856 -0.9808562 -0.8542897
##         PC33     PC34      PC35     PC36      PC37      PC38       PC39
## 1 -6.5560742 1.645860 0.5577230 2.953759 -1.876040 2.1480840  0.2240653
## 2 -0.9293229 2.249257 0.5591657 3.149219  0.942013 0.8371117 -0.1430096
##         PC40       PC41      PC42       PC43      PC44       PC45
## 1 -0.1399115  0.9951322 3.5729789 -0.1840558 -1.625440  0.6136480
## 2  0.1694784 -1.3032569 0.1537778  0.2178183  2.053742 -0.5062235
##         PC46       PC47       PC48       PC49       PC50
## 1 -1.3208149 -0.6872233  0.5674192 -0.5873786 -0.5788236
## 2  0.8679845 -0.6557365 -0.4997849  0.9293163  0.1233277
##   log10_total_features sex brain_hemisphere brain_subregion
## 1             3.916349   M                L              L5
## 2             3.918502   M                L              L5
##   facs_sort_criteria         class                 cluster cluster0
## 1      NeuN-positive Glutamatergic     Exc L5-6 RORB TTC12      Exc
## 2      NeuN-positive Glutamatergic Exc L5-6 FEZF2 EFTUD1P1      Exc
##       TSNE1     TSNE2
## 1 -2.004835 -34.56419
## 2 -4.155737  48.00538
</code></pre>

<pre><code class="r">for(one_var in all_vars){
    print(ggplot_custom(DATA = df_hvg,
        X = &quot;TSNE1&quot;,Y = &quot;TSNE2&quot;,COL = one_var))
}

reducedDims(sce_hvg) = SimpleList(PCA=pca, TSNE=tsne$Y)
sce_hvg
</code></pre>

<pre><code>## class: SingleCellExperiment 
## dim: 1051 13330 
## metadata(1): log.exprs.offset
## assays(2): counts logcounts
## rownames(1051): AASDHPPT AASS ... ZWINT ZXDB
## rowData names(16): gene chromosome ... n_cells_counts
##   pct_dropout_counts
## colnames(13330): F1S4_160106_001_C01 F1S4_160106_001_G01 ...
##   F2S4_170405_060_F01 F2S4_170405_060_H01
## colData names(97): sample_name sample_id ...
##   pct_counts_top_100_features_Ri PassQC
## reducedDimNames(2): PCA TSNE
## spikeNames(0):
</code></pre>

<pre><code class="r">saveRDS(list(sce_hvg=sce_hvg,df_hvg=df_hvg),&quot;post_redDim_HVG.rds&quot;)
</code></pre>

<p><img src="figure/unnamed-chunk-10-1.png" alt="plot of chunk unnamed-chunk-10"></p>

<h2>Clustering</h2>

<h3>Kmeans</h3>

<p>There are many methods for clustering of single cell RNA-seq data. The performance of each method may also depend on pre-processing steps, such as performing imputation or not. We wil compare these methods in a seperate document. Here we just illustrate the clustering reuslts using a simple kmeans method on the top 50 PCs. </p>

<pre><code class="r">all_num_clust = c(5:10,15:20,25:30)
df_hvg = df_hvg[,!grepl(&quot;^KM_&quot;,names(df_hvg))]
for(num_clust in all_num_clust){
    cat(paste0(&quot;KM with &quot;,num_clust,&quot; clusters.\n&quot;))
    kmeans_out = kmeans(reducedDim(sce_hvg,&quot;PCA&quot;),centers = num_clust,
        iter.max = 5e2,algorithm = &quot;MacQueen&quot;)
    df_hvg = smart_df(df_hvg,VV = as.factor(kmeans_out$cluster))
    names(df_hvg)[ncol(df_hvg)] = paste0(&quot;KM_&quot;,num_clust)
    print(ggplot_custom(DATA = df_hvg,X = &quot;TSNE1&quot;,
        Y = &quot;TSNE2&quot;,COL = paste0(&quot;KM_&quot;,num_clust)))
}
</code></pre>

<pre><code>## KM with 5 clusters.
</code></pre>

<p><img src="figure/unnamed-chunk-11-1.png" alt="plot of chunk unnamed-chunk-11"></p>

<pre><code>## KM with 6 clusters.
</code></pre>

<p><img src="figure/unnamed-chunk-11-2.png" alt="plot of chunk unnamed-chunk-11"></p>

<pre><code>## KM with 7 clusters.
</code></pre>

<p><img src="figure/unnamed-chunk-11-3.png" alt="plot of chunk unnamed-chunk-11"></p>

<pre><code>## KM with 8 clusters.
</code></pre>

<p><img src="figure/unnamed-chunk-11-4.png" alt="plot of chunk unnamed-chunk-11"></p>

<pre><code>## KM with 9 clusters.
</code></pre>

<p><img src="figure/unnamed-chunk-11-5.png" alt="plot of chunk unnamed-chunk-11"></p>

<pre><code>## KM with 10 clusters.
</code></pre>

<p><img src="figure/unnamed-chunk-11-6.png" alt="plot of chunk unnamed-chunk-11"></p>

<pre><code>## KM with 15 clusters.
</code></pre>

<p><img src="figure/unnamed-chunk-11-7.png" alt="plot of chunk unnamed-chunk-11"></p>

<pre><code>## KM with 16 clusters.
</code></pre>

<p><img src="figure/unnamed-chunk-11-8.png" alt="plot of chunk unnamed-chunk-11"></p>

<pre><code>## KM with 17 clusters.
</code></pre>

<p><img src="figure/unnamed-chunk-11-9.png" alt="plot of chunk unnamed-chunk-11"></p>

<pre><code>## KM with 18 clusters.
</code></pre>

<p><img src="figure/unnamed-chunk-11-10.png" alt="plot of chunk unnamed-chunk-11"></p>

<pre><code>## KM with 19 clusters.
</code></pre>

<p><img src="figure/unnamed-chunk-11-11.png" alt="plot of chunk unnamed-chunk-11"></p>

<pre><code>## KM with 20 clusters.
</code></pre>

<p><img src="figure/unnamed-chunk-11-12.png" alt="plot of chunk unnamed-chunk-11"></p>

<pre><code>## KM with 25 clusters.
</code></pre>

<p><img src="figure/unnamed-chunk-11-13.png" alt="plot of chunk unnamed-chunk-11"></p>

<pre><code>## KM with 26 clusters.
</code></pre>

<p><img src="figure/unnamed-chunk-11-14.png" alt="plot of chunk unnamed-chunk-11"></p>

<pre><code>## KM with 27 clusters.
</code></pre>

<p><img src="figure/unnamed-chunk-11-15.png" alt="plot of chunk unnamed-chunk-11"></p>

<pre><code>## KM with 28 clusters.
</code></pre>

<p><img src="figure/unnamed-chunk-11-16.png" alt="plot of chunk unnamed-chunk-11"></p>

<pre><code>## KM with 29 clusters.
</code></pre>

<p><img src="figure/unnamed-chunk-11-17.png" alt="plot of chunk unnamed-chunk-11"></p>

<pre><code>## KM with 30 clusters.
</code></pre>

<p><img src="figure/unnamed-chunk-11-18.png" alt="plot of chunk unnamed-chunk-11"></p>

<pre><code class="r"># Save temp image
saveRDS(list(sce_hvg=sce_hvg,df_hvg=df_hvg),&quot;post_HVG_kmeans.rds&quot;)
</code></pre>

<h3>SC3</h3>

<p>Code used here is based on <a href="https://bioconductor.org/packages/devel/bioc/vignettes/SC3/inst/doc/SC3.html#run-sc3">this link</a>.</p>

<pre><code class="r">library(SC3)
rowData(sce_hvg)$feature_symbol = rowData(sce_hvg)$gene
date()
</code></pre>

<pre><code>## [1] &quot;Mon Nov  5 16:18:08 2018&quot;
</code></pre>

<pre><code class="r">all_ks = c(5,10,12,15)
# all_ks = 10
sce_hvg = sc3(sce_hvg,ks = all_ks,biology = TRUE,
    n_cores = 1,rand_seed = 100,svm_num_cells = 2000)
</code></pre>

<pre><code>## Setting SC3 parameters...
</code></pre>

<pre><code>## Your dataset contains more than 2000 cells. Adjusting the nstart parameter of kmeans to 50 for faster performance...
</code></pre>

<pre><code>## Defining training cells for SVM using svm_num_cells parameter...
</code></pre>

<pre><code>## Calculating distances between the cells...
</code></pre>

<pre><code>## Performing transformations and calculating eigenvectors...
</code></pre>

<pre><code>## Performing k-means clustering...
</code></pre>

<pre><code>## Calculating consensus matrix...
</code></pre>

<pre><code>## Calculating biology...
</code></pre>

<pre><code class="r">warnings()
date()
</code></pre>

<pre><code>## [1] &quot;Tue Nov  6 00:24:27 2018&quot;
</code></pre>

<pre><code class="r"># Run SVM and predict labels of all other cells
date()
</code></pre>

<pre><code>## [1] &quot;Tue Nov  6 00:24:27 2018&quot;
</code></pre>

<pre><code class="r">sce_hvg = sc3_run_svm(sce_hvg, ks = all_ks)
date()
</code></pre>

<pre><code>## [1] &quot;Tue Nov  6 00:26:56 2018&quot;
</code></pre>

<pre><code class="r">saveRDS(list(sce_hvg=sce_hvg,all_ks=all_ks),&quot;post_HVG_sc3.rds&quot;)
# rds = readRDS(&quot;post_HVG_sc3.rds&quot;); sce_hvg = rds$sce_hvg; all_ks = rds$all_ks; rm(rds)

df_sc3 = smart_df(reducedDim(sce_hvg,&quot;TSNE&quot;))
rownames(df_sc3) = NULL
names(df_sc3) = paste0(&quot;TSNE&quot;,seq(ncol(df_sc3)))
df_sc3 = smart_df(sample_name = colnames(sce_hvg),df_sc3)
df_sc3$log10_total_features = colData(sce_hvg)$log10_total_features
df_sc3$sex = colData(sce_hvg)$sex
df_sc3$brain_hemisphere = colData(sce_hvg)$brain_hemisphere
df_sc3$brain_subregion = colData(sce_hvg)$brain_subregion
df_sc3$facs_sort_criteria = colData(sce_hvg)$facs_sort_criteria
df_sc3$class = colData(sce_hvg)$class
df_sc3$cluster = colData(sce_hvg)$cluster
df_sc3$cluster0 = colData(sce_hvg)$cluster0

all_vars = c(&quot;log10_total_features&quot;,&quot;sex&quot;,&quot;brain_hemisphere&quot;,
    &quot;brain_subregion&quot;,&quot;facs_sort_criteria&quot;,&quot;class&quot;,&quot;cluster0&quot;)

# TSNE plotting by cluster
for(one_ks in all_ks){
    df_sc3$VV = as.factor(colData(sce_hvg)[,paste0(&quot;sc3_&quot;,one_ks,&quot;_clusters&quot;)])
    names(df_sc3)[names(df_sc3) == &quot;VV&quot;] = paste0(&quot;SC3_&quot;,one_ks)
    print(ggplot_custom(DATA = df_sc3,X = &quot;TSNE1&quot;,
        Y = &quot;TSNE2&quot;,COL = paste0(&quot;SC3_&quot;,one_ks)))
}
</code></pre>

<p><img src="figure/unnamed-chunk-12-1.png" alt="plot of chunk unnamed-chunk-12"><img src="figure/unnamed-chunk-12-2.png" alt="plot of chunk unnamed-chunk-12"><img src="figure/unnamed-chunk-12-3.png" alt="plot of chunk unnamed-chunk-12"><img src="figure/unnamed-chunk-12-4.png" alt="plot of chunk unnamed-chunk-12"></p>

<pre><code class="r"># SC3 Plotting
for(one_ks in all_ks){
    # one_ks = all_ks[1]
    cat(paste0(&quot;Num Clusters = &quot;,one_ks,&quot;\n&quot;))
    plotPCA(sce_hvg,
        colour_by = paste0(&quot;sc3_&quot;,one_ks,&quot;_clusters&quot;), 
        size_by = paste0(&quot;sc3_&quot;,one_ks,&quot;_log2_outlier_score&quot;))

    sc3_plot_consensus(sce_hvg,k = one_ks,
        show_pdata = c(all_vars,
        paste0(&quot;sc3_&quot;,one_ks,&quot;_clusters&quot;), 
        paste0(&quot;sc3_&quot;,one_ks,&quot;_log2_outlier_score&quot;)))

    # sc3_plot_silhouette(sce_hvg, k = one_ks)

    sc3_plot_expression(sce_hvg, k = one_ks,
        show_pdata = c(all_vars,
        paste0(&quot;sc3_&quot;,one_ks,&quot;_clusters&quot;), 
        paste0(&quot;sc3_&quot;,one_ks,&quot;_log2_outlier_score&quot;)))

    sc3_plot_cluster_stability(sce_hvg, k = one_ks)

    #sc3_plot_de_genes(sce_hvg, k = one_ks, 
    #   show_pdata = c(all_vars,
    #   paste0(&quot;sc3_&quot;,one_ks,&quot;_clusters&quot;), 
    #   paste0(&quot;sc3_&quot;,one_ks,&quot;_log2_outlier_score&quot;)))

    sc3_plot_markers(sce_hvg, k = one_ks, 
        show_pdata = c(all_vars,
        paste0(&quot;sc3_&quot;,one_ks,&quot;_clusters&quot;), 
        paste0(&quot;sc3_&quot;,one_ks,&quot;_log2_outlier_score&quot;)))

}
</code></pre>

<pre><code>## Num Clusters = 5
</code></pre>

<p><img src="figure/unnamed-chunk-12-5.png" alt="plot of chunk unnamed-chunk-12"><img src="figure/unnamed-chunk-12-6.png" alt="plot of chunk unnamed-chunk-12"><img src="figure/unnamed-chunk-12-7.png" alt="plot of chunk unnamed-chunk-12"></p>

<pre><code>## Num Clusters = 10
</code></pre>

<p><img src="figure/unnamed-chunk-12-8.png" alt="plot of chunk unnamed-chunk-12"><img src="figure/unnamed-chunk-12-9.png" alt="plot of chunk unnamed-chunk-12"><img src="figure/unnamed-chunk-12-10.png" alt="plot of chunk unnamed-chunk-12"></p>

<pre><code>## Num Clusters = 12
</code></pre>

<p><img src="figure/unnamed-chunk-12-11.png" alt="plot of chunk unnamed-chunk-12"><img src="figure/unnamed-chunk-12-12.png" alt="plot of chunk unnamed-chunk-12"><img src="figure/unnamed-chunk-12-13.png" alt="plot of chunk unnamed-chunk-12"></p>

<pre><code>## Num Clusters = 15
</code></pre>

<p><img src="figure/unnamed-chunk-12-14.png" alt="plot of chunk unnamed-chunk-12"><img src="figure/unnamed-chunk-12-15.png" alt="plot of chunk unnamed-chunk-12"><img src="figure/unnamed-chunk-12-16.png" alt="plot of chunk unnamed-chunk-12"></p>

<h1>Session information</h1>

<pre><code class="r">sessionInfo()
</code></pre>

<pre><code>## R version 3.5.1 (2018-07-02)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Red Hat Enterprise Linux Server 7.5 (Maipo)
## 
## Matrix products: default
## BLAS: /nas/longleaf/home/pllittle/downloads/R-3.5.1/lib64/R/lib/libRblas.so
## LAPACK: /nas/longleaf/home/pllittle/downloads/R-3.5.1/lib64/R/lib/libRlapack.so
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] parallel  stats4    stats     graphics  grDevices utils     datasets 
## [8] methods   base     
## 
## other attached packages:
##  [1] SC3_1.8.0                   Rtsne_0.13                 
##  [3] svd_0.4.1                   limma_3.36.3               
##  [5] scran_1.8.4                 scater_1.8.4               
##  [7] ggplot2_3.0.0               biomaRt_2.36.1             
##  [9] DropletUtils_1.0.3          SingleCellExperiment_1.2.0 
## [11] SummarizedExperiment_1.10.1 DelayedArray_0.6.5         
## [13] BiocParallel_1.14.2         matrixStats_0.54.0         
## [15] Biobase_2.40.0              GenomicRanges_1.32.6       
## [17] GenomeInfoDb_1.16.0         IRanges_2.14.11            
## [19] S4Vectors_0.18.3            BiocGenerics_0.26.0        
## [21] rmarkdown_1.10              markdown_0.8               
## [23] knitr_1.20                 
## 
## loaded via a namespace (and not attached):
##   [1] ggbeeswarm_0.6.0         colorspace_1.3-2        
##   [3] rjson_0.2.20             class_7.3-14            
##   [5] dynamicTreeCut_1.63-1    rprojroot_1.3-2         
##   [7] XVector_0.20.0           DT_0.4                  
##   [9] bit64_0.9-7              mvtnorm_1.0-8           
##  [11] AnnotationDbi_1.42.1     codetools_0.2-15        
##  [13] tximport_1.8.0           doParallel_1.0.11       
##  [15] robustbase_0.93-2        cluster_2.0.7-1         
##  [17] pheatmap_1.0.10          shinydashboard_0.7.0    
##  [19] shiny_1.1.0              rrcov_1.4-4             
##  [21] compiler_3.5.1           httr_1.3.1              
##  [23] backports_1.1.2          assertthat_0.2.0        
##  [25] Matrix_1.2-14            lazyeval_0.2.1          
##  [27] later_0.7.3              htmltools_0.3.6         
##  [29] prettyunits_1.0.2        tools_3.5.1             
##  [31] bindrcpp_0.2.2           igraph_1.2.2            
##  [33] gtable_0.2.0             glue_1.3.0              
##  [35] GenomeInfoDbData_1.1.0   reshape2_1.4.3          
##  [37] dplyr_0.7.6              doRNG_1.7.1             
##  [39] Rcpp_0.12.18             gdata_2.18.0            
##  [41] iterators_1.0.10         DelayedMatrixStats_1.2.0
##  [43] stringr_1.3.1            mime_0.5                
##  [45] irlba_2.3.2              rngtools_1.3.1          
##  [47] gtools_3.8.1             WriteXLS_4.0.0          
##  [49] statmod_1.4.30           XML_3.98-1.16           
##  [51] DEoptimR_1.0-8           edgeR_3.22.3            
##  [53] zlibbioc_1.26.0          scales_1.0.0            
##  [55] hms_0.4.2                promises_1.0.1          
##  [57] rhdf5_2.24.0             RColorBrewer_1.1-2      
##  [59] memoise_1.1.0            gridExtra_2.3           
##  [61] pkgmaker_0.27            stringi_1.2.4           
##  [63] RSQLite_2.1.1            highr_0.7               
##  [65] pcaPP_1.9-73             foreach_1.4.4           
##  [67] e1071_1.7-0              caTools_1.17.1.1        
##  [69] bibtex_0.4.2             rlang_0.2.2             
##  [71] pkgconfig_2.0.2          bitops_1.0-6            
##  [73] evaluate_0.11            lattice_0.20-35         
##  [75] ROCR_1.0-7               purrr_0.2.5             
##  [77] Rhdf5lib_1.2.1           bindr_0.1.1             
##  [79] htmlwidgets_1.2          labeling_0.3            
##  [81] bit_1.1-14               tidyselect_0.2.4        
##  [83] plyr_1.8.4               magrittr_1.5            
##  [85] R6_2.2.2                 gplots_3.0.1            
##  [87] DBI_1.0.0                pillar_1.3.0            
##  [89] withr_2.1.2              RCurl_1.95-4.11         
##  [91] tibble_1.4.2             crayon_1.3.4            
##  [93] KernSmooth_2.23-15       viridis_0.5.1           
##  [95] progress_1.2.0           locfit_1.5-9.1          
##  [97] grid_3.5.1               data.table_1.11.4       
##  [99] blob_1.1.1               FNN_1.1.2.1             
## [101] digest_0.6.16            xtable_1.8-3            
## [103] httpuv_1.4.5             munsell_0.5.0           
## [105] registry_0.5             beeswarm_0.2.3          
## [107] viridisLite_0.3.0        vipor_0.4.5
</code></pre>

<h1>Reference</h1>

</body>

</html>
