#The protocol of our method

# 1. Using their default simulator for now. We can consider simulate 3000 genes in 40 individuals, 
#    with 20 cases vs. 20 controls. We can set DE for 300 genes in terms of mean expression difference, 
#    and another 300 genes DE in terms of variance difference. 
#    In the simulation, try to set the total read-depth across samples to be the same. 
#    As an initial analysis, do not add any covariates. 
#
# 2. For each gene, calculate density, and then JSD across samples, and then use PERMANOVA to calculate p-value for each gene. 
#    Also calculate p-value for each gene using MAST-mixed effect model (less priority for now). 
#
# 3. Collapse gene expression across cells per individual, then run DESeq2 for differential expression testing. 
#
# 4. Evaluate our method:
#    Type I error is the proportion of those 4000 equivalently expressed genes with p-value smaller than 0.05. 
#    Power1, the proportion of the first 500 genest with p-value < 0.05
#    Power2, the proportion of the next 500 genest with p-value < 0.05


#########################################################################
#                                                                       #
#                                                                       #
#                 Part I: scRNA seq data Simulation                     #
#                                                                       #
#                                                                       #
#########################################################################

#we simulate our sample scRNAseq data with zero inflated negative binomial distribution.
#The parameter can be generated by the parameter or estimated from the real data.
# in the following example, we simulate our data based on the real dataset from Velmeshev et al, 2019

#This dataset was generated using 10x Genomics platform(https://www.10xgenomics.com/).
#The read count data were downloaded from the link of "Gene / cell matrix (raw)" .
#from the interactive web browser at Velmeshev et al, 2019(https://cells.ucsc.edu/autism/).

#We apply the Deep count autoencoder(DCA) for denoising (https://github.com/theislab/dca) the data.
#Then we use the output of DCA as reference to simulate our data.

#in this senarios, we'd like to simulate

#Note:
#  (1)We simulate the cleared row counts data. In our simulation we didn't introduce batch effect or covariates now.
#  (2)In real data analysis, The data cleaning parts are expected prior before our method.

##############general paramter setting for our simulation####################

require("emdbook")


nGeneMean=300   #number of genes who has different means in cases individuals
nGeneVar=300    #number of genes who has different varibility in cases individuals
nGeneBlank=2400 #number of genes who has no differences between cases and controls.
nGeneTotal=nGeneMean+nGeneVar+nGeneBlank #total numbers of genes
ncase=20        #case individuals
nctrl=20        #control individuals
ncell=100       #numbers of cells collected from each individuals.

r_mean=2      #The expected fold-changes in mean
r_var=4         #The expected fold-changes in variances

#setting the index
i_mean=1:nGeneMean
i_var=(nGeneMean+1):(nGeneMean+nGeneVar)
i_blank=(nGeneMean+nGeneVar+1):nGeneTotal

i_case=1:ncase*ncell
i_ctrl=(ncase*ncell+1):((ncase+nctrl)*ncell)



###################### load the reference real data ##########################

# The major output of DCA includes 3 files, 
# which describes the mean/dipersion/dropout probabilities of each gene in each cell.
# According to their official website(https://github.com/theislab/dca):

# mean.tsv is the main output of the method which represents the mean parameter of the ZINB distribution. 
# This file has the same dimensions as the input file (except that the zero-expression genes or cells are excluded). 
# It is formatted as a gene x cell matrix.

# pi.tsv and dispersion.tsv files represent dropout probabilities and dispersion for each cell and gene. 

# Matrix dimensions are same as mean.tsv and the input file.

#load the data
setwd("/Users/mzhang24/Desktop/fh/Data_PRJNA434002/res_dca_rawM3k10/")
setwd("/fh/fast/sun_w/mengqi/Data_PRJNA434002/res_dca_rawM3k10/")
t_mean=read.table(paste0("mean_signif4.tsv.gz"),stringsAsFactors = FALSE)
t_dispersion=read.table(paste0("dispersion_signif4.tsv.gz"),stringsAsFactors = FALSE,row.names = 1)
t_dropout=read.table(paste0("dropout_signif4.tsv.gz"),stringsAsFactors = FALSE,row.names = 1)


###################### simulation based on real data ##########################

#extract information from the data
#for better catch of the parameters, we get the gene specific medians of each parameter.
# We then do a log/logit transform and using the gaussian distribution to model them and simulate parameters.

#get the median
mid_mean=apply(t_mean,1,median)
mid_dispersion=apply(t_dispersion,1,median)
mid_dropout=apply(t_dropout,1,median)

#log/logit transformation
log_mean_sample=(log(as.numeric(mid_mean)))
log_disp_sample=(log(as.numeric(mid_dispersion)))
logit_drop_sample=(log(as.numeric(mid_dropout)/(1-as.numeric(mid_dropout))))

#simulate parameters based on the real data, based on gaussian distribution.
Pram_log_mean=rnorm(nGeneMean+nGeneVar+nGeneBlank,mean = (log_mean_sample),sd=sd(log_mean_sample))
Pram_log_disp=rnorm(nGeneMean+nGeneVar+nGeneBlank,mean = (log_disp_sample),sd=sd(log_disp_sample))
Pram_logit_drop=rnorm(nGeneMean+nGeneVar+nGeneBlank,mean = (logit_drop_sample),sd=sd(logit_drop_sample))

#Calculate the co-variance among parameters.
sample_data=cbind(log_mean_sample,log_disp_sample,logit_drop_sample)
sample_mean=apply(sample_data,2,mean)
sample_var=apply(sample_data,2,var)

cov_matrix=matrix(NA,3,3)
for(i in 1:3){
  for(j in 1:3){
    cov_matrix[i,j]=cov(sample_data[,i],sample_data[,j])
  }
}

#simulate scRNAseq ZINB parameters based on the simulated parameters for the control conditions.
require(MASS)
gpar_ctrl=exp(mvrnorm(nGeneTotal, mu = sample_mean, Sigma = cov_matrix,empirical = TRUE))
gpar_ctrl[,3]=gpar_ctrl[,3]/(1+gpar_ctrl[,3])


#sample the genes to label as differential expressed in means and variances.

special_index=sample.int(nGeneTotal,(nGeneMean+nGeneVar))
mean_index=as.numeric(special_index[i_mean])
var_index=as.numeric(special_index[i_var])

#label and save the DE index information.
de.mean=matrix(0,ncol=1,nrow=nGeneTotal)
de.var=matrix(0,ncol=1,nrow=nGeneTotal)
de.mean[mean_index]=1
de.var[var_index]=1


#To make sure the meanings of parameters and make sure all parameters are non-negative, we do some transformation
r_mean2=r_mean
r_var2=r_var  
if(r_mean>1){r_mean2=1/r_mean}
if(r_var<1){r_var2=1/r_var}

#tune the parameters for targeted mean/variance changes.

#the function calc_nb_param 
# returns the parameters for changing mean and variance of the negative binomial distribution
#require:  r_m/r_v <1+mu/theta
calc_nb_param=function(mu,theta,r_m=1,r_v=1){
  #mu=mean
  #theta=overdispersion
  mu2=r_m*mu
  theta2=theta*r_m*r_m*mu/(mu*r_v+(r_v-r_m)*theta)
  return(c(mu2,theta2))
}

#modify parameters for cases.
gpar_case=gpar_ctrl
gpar_case[mean_index,1:2]=t(apply(gpar_case[mean_index,1:2,drop=FALSE],1,
                                  function(x){return(calc_nb_param(x[1],x[2],r_m=r_mean2))})) #50% enlarge #50%shrinkage
gpar_case[var_index,1:2]=t(apply(gpar_case[var_index,1:2,drop=FALSE],1,
                                 function(x){return(calc_nb_param(x[1],x[2],r_v=r_var2))})) #50% enlarge #50%shrinkage

#simulate scRNAseq based on zinb parameters of cases and controls:
sim_case=matrix(nrow=nGeneTotal,ncol=ncase*ncell)
sim_ctrl=matrix(nrow=nGeneTotal,ncol=nctrl*ncell)

for(ig in 1:nGeneTotal){
  sim_case[ig,]=emdbook::rzinbinom(ncase*ncell,gpar_case[ig,1], gpar_case[ig,2], gpar_case[ig,3])
  sim_ctrl[ig,]=emdbook::rzinbinom(ncase*ncell,gpar_ctrl[ig,1], gpar_ctrl[ig,2], gpar_ctrl[ig,3])
}

#check about the simulated data

sim_case[1:10,1:10]
sim_ctrl[1:10,1:10]

sim_case[mean_index[1:10],1:10]
sim_ctrl[mean_index[1:10],1:10]

sim_case[var_index[1:10],1:10]
sim_ctrl[var_index[1:10],1:10]

####################simulation results visualization#######################
op=par(mfrow = c(2, 3), pty = "s")

#histograms
hist(log(apply(sim_ctrl[de.mean+de.var==0,],1,mean)),
     breaks=15,xlim=c(-6,2), main="log of mean count, non-DE genes in control")
hist(log(apply(sim_ctrl[de.mean==1,],1,mean)),
     breaks=15, xlim=c(-6,2), main="log of mean count, Mean-DE genes in control")
hist(log(apply(sim_ctrl[de.var==1,],1,mean)),
     breaks=15, xlim=c(-6,2), main="log of mean count, Var-DE genes in control")

hist(log(apply(sim_case[de.mean+de.var==0,],1,mean)),
     col=rgb(1,0,0,0.3),breaks=15, xlim=c(-6,2), main="log of mean count, non-DE genes in case")
hist(log(apply(sim_case[de.mean==1,],1,mean)),
     col=rgb(1,0,0,0.3),breaks=15, xlim=c(-6,2), main="log of mean count, Mean-DE genes in case")
hist(log(apply(sim_case[de.var==1,],1,mean)),
     col=rgb(1,0,0,0.3),breaks=15, xlim=c(-6,2), main="log of mean count, Var-DE genes in case")

hist(log(apply(sim_ctrl[de.mean+de.var==0,],1,var)),
     breaks=15, xlim=c(-6,2), main="log of var count, non-DE genes in control")
hist(log(apply(sim_ctrl[de.mean==1,],1,var)),
     breaks=15, xlim=c(-6,2), main="log of var count, Mean-DE genes in control")
hist(log(apply(sim_ctrl[de.var==1,],1,var)),
     breaks=15, xlim=c(-6,2), main="log of var count, Var-DE genes in control")

hist(log(apply(sim_case[de.mean+de.var==0,],1,var)),
     col=rgb(1,0,0,0.3),breaks=15, xlim=c(-6,2), main="log of var count, non-DE genes in case")
hist(log(apply(sim_case[de.mean==1,],1,var)),
     col=rgb(1,0,0,0.3),breaks=15, xlim=c(-6,2), main="log of var count, Mean-DE genes in case")
hist(log(apply(sim_case[de.var==1,],1,var)),
     col=rgb(1,0,0,0.3),breaks=15, xlim=c(-6,2), main="log of var count, Var-DE genes in case")

#QQ plots
plot(sort(log(apply(sim_ctrl[de.mean+de.var==0,],1,mean))),sort(log(apply(sim_case[de.mean+de.var==0,],1,mean))),
     cex=.1, xlab="control cells",ylab="case cells",main="QQ plot: log of mean count, non-DE genes")
lines(c(-10,10),c(-10,10),col="red")
plot(sort(log(apply(sim_ctrl[de.mean==1,],1,mean))),sort(log(apply(sim_case[de.mean==1,],1,mean))),
     cex=.1, xlab="control cells",ylab="case cells",main="QQ plot: log of mean count, Mean-DE genes")
lines(c(-10,10),c(-10,10),col="red")
plot(sort(log(apply(sim_ctrl[de.var==1,],1,mean))),sort(log(apply(sim_case[de.var==1,],1,mean))),
     cex=.1, xlab="control cells",ylab="case cells",main="QQ plot: log of mean count, Var-DE genes")
lines(c(-10,10),c(-10,10),col="red")


plot(sort(log(apply(sim_ctrl[de.mean+de.var==0,],1,var))),sort(log(apply(sim_case[de.mean+de.var==0,],1,var))),
     cex=.1, xlab="control cells",ylab="case cells",main="QQ plot: log of var count, non-DE genes")
lines(c(-10,10),c(-10,10),col="red")
plot(sort(log(apply(sim_ctrl[de.mean==1,],1,var))),sort(log(apply(sim_case[de.mean==1,],1,var))),
     cex=.1, xlab="control cells",ylab="case cells",main="QQ plot: log of var count, Mean-DE genes")
lines(c(-10,10),c(-10,10),col="red")
plot(sort(log(apply(sim_ctrl[de.var==1,],1,var))),sort(log(apply(sim_case[de.var==1,],1,var))),
     cex=.1, xlab="control cells",ylab="case cells",main="QQ plot: log of var count, Var-DE genes")
lines(c(-10,10),c(-10,10),col="red")

par(op)

#the matrix including the simulated results
sim_matrix=cbind(sim_case,sim_ctrl)


####################### Meta information collection #################

#the phenotype and individual information of simulated samples.
phenotype=c(rep(1,ncase*ncell),rep(0,nctrl*ncell))
individual=paste0("ind",c(rep(1:(ncase+nctrl),each=ncell)))

#Count info for matrix
cell_id=paste0("cell",1:ncol(sim_matrix))
gene_id=paste0("gene",1:nrow(sim_matrix))

rownames(sim_matrix)=gene_id
colnames(sim_matrix)=cell_id

#Cell info for meta
cellsum=apply(sim_matrix,2,sum)
genesum=apply(sim_matrix,1,sum)
CDR=apply(sim_matrix>0,2,sum)/nrow(sim_matrix)
meta=data.frame(cbind(cell_id,individual,phenotype,cellsum,CDR))

######### Some basic stat & Preparation for Bulk RNAseq analysis ###########################

#individual level info
cur_individual=unique(meta$individual)
cell_num=matrix(ncol=1,nrow=length(cur_individual))
rownames(cell_num)=cur_individual
colnames(cell_num)="cell_num"
read_depth=matrix(ncol=1,nrow=length(cur_individual))
rownames(read_depth)=cur_individual
colnames(read_depth)="read_depth"
phenotype_ind=matrix(ncol=1,nrow=length(cur_individual))
rownames(phenotype_ind)=cur_individual
colnames(phenotype_ind)="phenotype"

zero_rate_ind=matrix(nrow=nrow(sim_matrix),ncol=length(cur_individual))
rownames(zero_rate_ind)=rownames(sim_matrix)
colnames(zero_rate_ind)=cur_individual
sim_matrix_bulk=matrix(nrow=nrow(sim_matrix),ncol=length(cur_individual))
rownames(sim_matrix_bulk)=rownames(sim_matrix)
colnames(sim_matrix_bulk)=cur_individual

for(i_ind in 1:length(cur_individual)){
  cur_ind=cur_individual[i_ind]
  #fit org
  cur_ind_m=sim_matrix[,meta$individual==cur_ind]
  cell_num[i_ind]=ncol(cur_ind_m)
  read_depth[i_ind]=sum(cur_ind_m,na.rm = TRUE)/cell_num[i_ind]*1000
  phenotype_ind[i_ind]=meta$phenotype[meta$individual==cur_ind][1]
  
  zero_rate_ind[,i_ind]=apply(cur_ind_m==0,1,function(x){return(sum(x,na.rm = TRUE))})/cell_num[i_ind]
  sim_matrix_bulk[,i_ind]=apply(cur_ind_m==0,1,function(x){return(sum(x,na.rm = TRUE))})
}

hist(read_depth)


#########################################################################
#                                                                       #
#                                                                       #
#             Part II: Defferential Expression Analysis                 #
#                                                                       #
#                                                                       #
#########################################################################
# once simulated genes, we will do the Differential Expression Analysis
# Here we will implement our method, plus the DESeq analysis and the MAST analysis. 

######################1. Our distance method#####################################
#our method includes 3 major steps:
#1.Model the distribution of the scRNAseq counts of each individual, 
#    this method can be done with Zero-Inflated Negative Binomial(ZINB) model or just empirical distribution

#2.Calculate the distance between each individuals, 
#    using the Symmetrised Kullback-Leibler divergence or the Jensen-Shannon divergence

#3. Summaries those distance and calculate case-control level comparison based on permuation method.
#    The Manova method developed by Anderson MJ, 2001 and the Permanova-S method developed by Tang ZZ et al, 2016 was applied.
#
#input
#sim_matrix
#meta

##package and functions ###############
library("emdbook")
library("ggplot2")
source("/fh/fast/sun_w/mengqi/1.Testing_scRNAseq/Command/7.0_ZINB_fit_functions.R")
source("/fh/fast/sun_w/mengqi/1.Testing_scRNAseq/Command/8.0_kl_divergence_functions.R")
source("/fh/fast/sun_w/mengqi/1.Testing_scRNAseq/Command/9.0_Fstat_functions.R")


cur_info=meta[,c("individual","phenotype")]
cur_info=unique(cur_info)
rownames(cur_info)=cur_info$individual
phenotype=as.numeric(cur_info[,2])-1


##### STEP 1: fit sim data by with ZINB models #####

# this part fits the distribution of counts of each individuals of each gene with ZINB models,
# opt out this part if only interested in describing this distribution with empirical method.

cur_individual=unique(meta$individual)
sim_fit=array(dim=c(nrow(sim_matrix),length(cur_individual),3),
              dimnames = list(rownames(sim_matrix),cur_individual,c("logmean","dispersion","dropout_rate")))

for(i_g in 1:nrow(sim_matrix)){
  for(i_ind in 1:length(cur_individual)){
    cur_ind=cur_individual[i_ind]
    #fit org
    cur_org_ind=sim_matrix[i_g,meta$individual==cur_ind]
    sim_fit[i_g,i_ind,]=fit_nbzinb(cur_org_ind)
    
    #visualization for some of the distribution
    if(i_g<=5 & i_ind<=3){
      cur_org_ind=data.frame(cur_org_ind)
      colnames(cur_org_ind)="raw_count"
      ggplot(cur_org_ind, aes(x=raw_count),stat="count") + geom_histogram(fill="lightblue")+
        labs(title=paste0("Histogram of rawcount, ",rownames(sim_matrix)[i_g]," of ",cur_ind),x="Count", y = "Frequency")
      #+theme_classic()
    }
  }
  print(c("ind fit",i_g))
}

sim_fit[,,1]=exp(sim_fit[,,1]) #change the log mean to mean!!!


####STEP 2: JSD and KL calculation ######
#   Calculate the distance between each individuals, 
   
#   suppose we have distribution P and Q 
#   Define: M=(P+Q)/2 and D(P||Q)=-sum((P * (log(Q/P)))), then

#   (1)the Symmetrised Kullback-Leibler divergence: 
#         KLmean=1/2 * (D(P||Q)+D(Q||P))

#   (2)the Jensen-Shannon divergence:
#           JSD=1/2 * (D(P||M)+D(Q||M))


dist_method="JSD"        #c("mean","JSD")
fit_method="empirical"   #c("empirical","zinb")


dist_array=array(dim=c(nrow(sim_matrix),length(cur_individual),length(cur_individual)),
                 dimnames = list(rownames(sim_matrix),cur_individual,cur_individual))

###Option 1: if we fitted the distribution of expression with empirical method, we calculate:

for(i_g in 1:nrow(sim_matrix)){
  cur_sim=sim_matrix[i_g,]
  for(i_ind_a in 1:length(cur_individual)){
    for(i_ind_b in 1:length(cur_individual)){
      cur_ind_a=cur_individual[i_ind_a]
      cur_ind_b=cur_individual[i_ind_b]
      #fit sim
      cur_sim_ind_a=as.numeric(cur_sim[meta$individual==cur_ind_a])
      cur_sim_ind_b=as.numeric(cur_sim[meta$individual==cur_ind_b])
      
      dist_array[i_g,i_ind_a,i_ind_b]=tryCatch(mean_KL_dens(cur_sim_ind_a,cur_sim_ind_b,alter=dist_method,fit_model=fit_method), error = function(e) {NA} )
    }
  }
  print(i_g)
}


#if we fitted the distribution of expression with zinb model, we calculate:

for(i_g in 1:nrow(sim_fit)){
  cur_fit=sim_fit[i_g,,]
  for(i_ind_a in 1:length(cur_individual)){
    for(i_ind_b in 1:length(cur_individual)){
      cur_a=cur_fit[i_ind_a,]
      cur_b=cur_fit[i_ind_b,]
      #kl and jsd
      dist_array[i_g,i_ind_a,i_ind_b]=tryCatch(mean_KL_dens(cur_a,cur_b,alter=dist_method,zinb.quantile=0.975,fit_model=fit_method), error = function(e) {NA} )
    }
  }
  print(i_g)
}


#####STEP3: pval calculation: manova and permanova-S method #######################
#Summaries those distance and calculate case-control level comparison based on permuation method.
# The Manova method developed by Anderson MJ, 2001 and the Permanova-S method developed by Tang ZZ et al, 2016 was applied.
# the pvalue is calculated based on permutation method with minimium 500 times(default) permutation.

print("start permanova calculation")

dist_pval=cal_permanova_pval2(dist_array,phenotype)


#########################2. DESeq2 analysis#########################################
#We calculate bulk information by summing up raw counts of 
# all cells(of certain cluster) of an individual within a genes

#inputs:
#meta file
#sim_matrix_bulk

library("DESeq2")

perm_num=500 #number of permutation

cur_info=meta[,c("individual","phenotype")]
cur_info=unique(cur_info)
rownames(cur_info)=cur_info$individual

#object construction
dds=DESeqDataSetFromMatrix(countData = sim_matrix_bulk,
                           colData = cur_info,
                           design = ~ phenotype)

#observed pvalue calculation
dds=DESeq(dds)
de_ob_pval=results(dds)$pvalue

#permutation
de_perm_pval=matrix(ncol=perm_num,nrow=nrow(sim_matrix_bulk))
for(ip in 1:perm_num){
  respval=1
  cur_info$phenotype=cur_info$phenotype[sample.int(nrow(cur_info))]
  dds=DESeqDataSetFromMatrix(countData = sim_matrix_bulk,
                             colData = cur_info,
                             design = ~ phenotype)
  dds=DESeq(dds)
  respval=results(dds)$pvalue
  de_perm_pval[,ip]=respval
  print(ip)
}

#get the permutation pvalues
de_pval=rowSums(de_perm_pval-de_ob_pval<=0)/perm_num

de_pval


#########################3. MAST analysis##########################################

# the input of MAST analysis can be many format including matrix and SingleCellAssay.

# input:
# (1)the log-transformed expression count matrix, 
#     with each column represents the cells and each rows represents the genes.
# (2)the meta data, including cell information and individual information.

# we get the p-values based on the Hurdle model ("H" model)

# due to the speed of MAST analysis, we run each permutation on seperate jobs 
#  and then gather all results to calculate permutation p-values.

perm_tag=0


library("moments")
sim_matrix_log = log2(1 + sim_matrix) #log transformed data

dim(sim_matrix_log)
sim_matrix_log[1:10,1:10]
cell_id=colnames(sim_matrix_log)   #get the cell id from the data
gene_id=rownames(sim_matrix_log)   #get the gene id from the data

diagnosis=as.character(meta$phenotype) #
diagnosis[diagnosis==1]="Case"
diagnosis[diagnosis==0]="Control"

library("MAST")
library("lme4")

fData=data.frame(primerid=gene_id)
cData=data.frame(wellKey=cell_id)
colnames(meta)
length(fData)
length(cData)

sca=FromMatrix(sim_matrix_log, cData, fData)
colData(sca)$cngeneson = as.numeric(meta$CDR) #from Chong and Paul
colData(sca)$diagnosis =as.factor(diagnosis)
colData(sca)$ind = as.factor(meta$individual)

colData(sca)


#do a permutation #block out this part if no permutation needed.
if(perm_tag>0){
  #count cases and controls
  diag_info=paste0(colData(sca)$ind,":",colData(sca)$diagnosis)
  diag_kind=unique(diag_info)
  diag_kind=t(apply(as.matrix(diag_kind),1,function(x){return(unlist(strsplit(x,":")))}))
  
  #permute by mislabeling cases and controls
  diag_kind[,2]=diag_kind[sample.int(nrow(diag_kind),nrow(diag_kind),replace=F),2]
  
  #match back to each individuals
  ind_index=match(colData(sca)$ind,diag_kind[,1])
  colData(sca)$diagnosis=as.factor(diag_kind[ind_index,2])
}

b=zlm(formula=~diagnosis + ind + cngeneson, sca=sca)
bs=summary(b,logFC=TRUE,doLRT = paste0("diagnosis","Control"), level = 0.95)


bs$datatable


MAST_cur=bs$datatable
MAST_cur=MAST_cur[MAST_cur$contrast=="diagnosisControl",c("component","primerid","Pr(>Chisq)")]


#restriction for our analysis on model H
MAST_cur_pval=c(MAST_cur[MAST_cur$component=="H","Pr(>Chisq)"])
MAST_cur_pval=unlist(MAST_cur_pval)

MAST_cur_pval

####################################### END #############################################
sessionInfo()
q(save="no")






